[
    {
        "instance_id": "nokiatech-heif-88",
        "repo": "nokiatech/heif",
        "created_at": "2020-08-04T14:07:51+00:00",
        "problem_statement": "Alloc-dealloc-mismatch in iteminfobox.cpp:127:5\n\n## System info\r\n\r\nUbuntu X64, gcc (Ubuntu 5.5.0-12ubuntu1), heif (latest master [2fc78e](https://github.com/nokiatech/heif/commit/2fc78e4c80e9dbd22b5b0e09c137985d21d75512))\r\n\r\n## Configure\r\n\r\ncmake ../srcs -DCMAKE_CXX_FLAGS=\"-fsanitize=address -g\" -DCMAKE_C_FLAGS=\"-fsanitize=address -g\" -DCMAKE_EXE_LINKER_FLAGS=\"-fsanitize=address\" \r\n\r\n## Command line\r\n\r\nmodify example.cpp, use example7() to receive filename from command-line.\r\n\r\n./build/bin/example @@\r\n\r\n## AddressSanitizer output\r\n\r\n```\r\n=================================================================\r\n==36085==ERROR: AddressSanitizer: alloc-dealloc-mismatch (malloc vs operator delete) on 0x60c000000040\r\n    #0 0x51bac0 in operator delete(void*) /home/seviezhou/llvm-6.0.0/projects/compiler-rt/lib/asan/asan_new_delete.cc:149\r\n    #1 0x739be0 in std::_Sp_counted_ptr<FDItemInfoExtension*, (__gnu_cxx::_Lock_policy)2>::_M_dispose() /usr/lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/shared_ptr_base.h:377:9\r\n    #2 0x5b2a1f in std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release() /usr/lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/shared_ptr_base.h:155:6\r\n    #3 0x734570 in std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count() /usr/lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/shared_ptr_base.h:728:11\r\n    #4 0x734570 in std::__shared_ptr<ItemInfoExtension, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() /usr/lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/shared_ptr_base.h:1167\r\n    #5 0x734570 in ItemInfoEntry::~ItemInfoEntry() /home/seviezhou/heif/srcs/common/iteminfobox.cpp:143\r\n    #6 0x733188 in ItemInfoBox::parseBox(ISOBMFF::BitStream&) /home/seviezhou/heif/srcs/common/iteminfobox.cpp:127:5\r\n    #7 0x767976 in MetaBox::parseBox(ISOBMFF::BitStream&) /home/seviezhou/heif/srcs/common/metabox.cpp:278:26\r\n    #8 0x544693 in HEIF::HeifReaderImpl::handleMeta(HEIF::StreamIO&) /home/seviezhou/heif/srcs/reader/heifreaderimpl.cpp:559:17\r\n    #9 0x530462 in HEIF::HeifReaderImpl::readStream() /home/seviezhou/heif/srcs/reader/heifreaderimpl.cpp:846:37\r\n    #10 0x52c863 in HEIF::HeifReaderImpl::initialize(HEIF::StreamInterface*) /home/seviezhou/heif/srcs/reader/heifreaderimpl.cpp:120:31\r\n    #11 0x52c2a1 in HEIF::HeifReaderImpl::initialize(char const*) /home/seviezhou/heif/srcs/reader/heifreaderimpl.cpp:94:14\r\n    #12 0x51f2f3 in main /home/seviezhou/heif/srcs/examples/example.cpp:41:17\r\n    #13 0x7fcc5100b83f in __libc_start_main /build/glibc-e6zv40/glibc-2.23/csu/../csu/libc-start.c:291\r\n    #14 0x41f0b8 in _start (/home/seviezhou/heif/build/bin/example+0x41f0b8)\r\n\r\n0x60c000000040 is located 0 bytes inside of 120-byte region [0x60c000000040,0x60c0000000b8)\r\nallocated by thread T0 here:\r\n    #0 0x4e32c8 in __interceptor_malloc /home/seviezhou/llvm-6.0.0/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:88\r\n    #1 0x7334e4 in ItemInfoEntry::parseBox(ISOBMFF::BitStream&) /home/seviezhou/heif/srcs/common/iteminfobox.cpp:305:33\r\n    #2 0x767976 in MetaBox::parseBox(ISOBMFF::BitStream&) /home/seviezhou/heif/srcs/common/metabox.cpp:278:26\r\n    #3 0x544693 in HEIF::HeifReaderImpl::handleMeta(HEIF::StreamIO&) /home/seviezhou/heif/srcs/reader/heifreaderimpl.cpp:559:17\r\n    #4 0x530462 in HEIF::HeifReaderImpl::readStream() /home/seviezhou/heif/srcs/reader/heifreaderimpl.cpp:846:37\r\n    #5 0x52c863 in HEIF::HeifReaderImpl::initialize(HEIF::StreamInterface*) /home/seviezhou/heif/srcs/reader/heifreaderimpl.cpp:120:31\r\n    #6 0x52c2a1 in HEIF::HeifReaderImpl::initialize(char const*) /home/seviezhou/heif/srcs/reader/heifreaderimpl.cpp:94:14\r\n    #7 0x7fcc5100b83f in __libc_start_main /build/glibc-e6zv40/glibc-2.23/csu/../csu/libc-start.c:291\r\n\r\nSUMMARY: AddressSanitizer: alloc-dealloc-mismatch /home/seviezhou/llvm-6.0.0/projects/compiler-rt/lib/asan/asan_new_delete.cc:149 in operator delete(void*)\r\n==36085==HINT: if you don't care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\r\n==36085==ABORTING\r\n```\r\n\r\n## POC\r\n\r\n[alloc-dealloc-mismatch-parseBox-iteminfobox-127.zip](https://github.com/nokiatech/heif/files/5032675/alloc-dealloc-mismatch-parseBox-iteminfobox-127.zip)",
        "hints_text": "lassehe: Thank you for reporting this. Fix for this was included in commit b26a7086cb3eba61872f44c7902c54417f1084d5.",
        "base_commit": "2fc78e4c80e9dbd22b5b0e09c137985d21d75512",
        "patch": "diff --git a/srcs/.clang-format b/srcs/.clang-format\nindex 442037e..83a876e 100644\n--- a/srcs/.clang-format\n+++ b/srcs/.clang-format\n@@ -38,3 +38,5 @@ MaxEmptyLinesToKeep: 2\n NamespaceIndentation: All\n ReflowComments: true\n UseTab: Never\n+DerivePointerAlignment: false\n+PointerAlignment: Left\ndiff --git a/srcs/CMakeLists.txt b/srcs/CMakeLists.txt\nindex e25b7e9..d50bf6f 100644\n--- a/srcs/CMakeLists.txt\n+++ b/srcs/CMakeLists.txt\n@@ -129,7 +129,7 @@ execute_process(\n \n if(GIT_ERROR)\n     message( \"Could not get version information from git\")\n-    set(GIT_DESCRIBE \"v3.6.0\")\n+    set(GIT_DESCRIBE \"v3.6.1\")\n endif()\n \n # Get build timestamp\ndiff --git a/srcs/api-java/cpp/AlternateGroupJNI.cpp b/srcs/api-java/cpp/AlternateGroupJNI.cpp\nindex 4871391..512f529 100644\n--- a/srcs/api-java/cpp/AlternateGroupJNI.cpp\n+++ b/srcs/api-java/cpp/AlternateGroupJNI.cpp\n@@ -24,7 +24,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::EntityGroup(nativeHeif, HEIF::FourCC(\"altr\"));\n+        auto* nativeObject = new HEIFPP::EntityGroup(nativeHeif, HEIF::FourCC(\"altr\"));\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n }\ndiff --git a/srcs/api-java/cpp/AuxiliaryPropertyJNI.cpp b/srcs/api-java/cpp/AuxiliaryPropertyJNI.cpp\nindex a4678a7..e0a6a06 100644\n--- a/srcs/api-java/cpp/AuxiliaryPropertyJNI.cpp\n+++ b/srcs/api-java/cpp/AuxiliaryPropertyJNI.cpp\n@@ -26,7 +26,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::AuxiliaryProperty(nativeHeif);\n+        auto* nativeObject = new HEIFPP::AuxiliaryProperty(nativeHeif);\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n \n@@ -34,7 +34,7 @@ extern \"C\"\n     JNI_METHOD_ARG(void, setTypeNative, jstring javaString)\n     {\n         NATIVE_SELF;\n-        const char *nativeString = env->GetStringUTFChars(javaString, nullptr);\n+        const char* nativeString = env->GetStringUTFChars(javaString, nullptr);\n         nativeSelf->auxType(nativeString);\n         env->ReleaseStringUTFChars(javaString, nativeString);\n     }\n@@ -48,7 +48,7 @@ extern \"C\"\n     JNI_METHOD_ARG(void, setSubTypeNative, jbyteArray subType)\n     {\n         NATIVE_SELF;\n-        jbyte *nativeData = env->GetByteArrayElements(subType, nullptr);\n+        jbyte* nativeData = env->GetByteArrayElements(subType, nullptr);\n         auto dataSize     = static_cast<uint32_t>(env->GetArrayLength(subType));\n         std::vector<uint8_t> dataAsVector;\n         dataAsVector.reserve(dataSize);\n@@ -60,7 +60,7 @@ extern \"C\"\n     JNI_METHOD(jobject, getSubTypeNative)\n     {\n         NATIVE_SELF;\n-        return env->NewDirectByteBuffer(const_cast<uint8_t *>(nativeSelf->subType().data()),\n+        return env->NewDirectByteBuffer(const_cast<uint8_t*>(nativeSelf->subType().data()),\n                                         static_cast<jlong>(nativeSelf->subType().size()));\n     }\n }\ndiff --git a/srcs/api-java/cpp/CleanAperturePropertyJNI.cpp b/srcs/api-java/cpp/CleanAperturePropertyJNI.cpp\nindex 94f412f..3668b7e 100644\n--- a/srcs/api-java/cpp/CleanAperturePropertyJNI.cpp\n+++ b/srcs/api-java/cpp/CleanAperturePropertyJNI.cpp\n@@ -21,8 +21,8 @@\n \n extern \"C\"\n {\n-    jobject createFraction(JNIEnv *env, jobject obj, int numerator, int denominator);\n-    jobject createFraction(JNIEnv *env, jobject obj, int numerator, int denominator)\n+    jobject createFraction(JNIEnv* env, jobject obj, int numerator, int denominator);\n+    jobject createFraction(JNIEnv* env, jobject obj, int numerator, int denominator)\n     {\n         const jclass javaClass = env->GetObjectClass(obj);\n \n@@ -37,7 +37,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::CleanApertureProperty(nativeHeif);\n+        auto* nativeObject = new HEIFPP::CleanApertureProperty(nativeHeif);\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n \ndiff --git a/srcs/api-java/cpp/CodedImageItemJNI.cpp b/srcs/api-java/cpp/CodedImageItemJNI.cpp\nindex 81cb0bc..f8ee4f8 100644\n--- a/srcs/api-java/cpp/CodedImageItemJNI.cpp\n+++ b/srcs/api-java/cpp/CodedImageItemJNI.cpp\n@@ -30,15 +30,15 @@ extern \"C\"\n     JNI_METHOD(jobject, getItemDataNative)\n     {\n         NATIVE_SELF;\n-        return env->NewDirectByteBuffer(const_cast<uint8_t *>(nativeSelf->getItemData()),\n+        return env->NewDirectByteBuffer(const_cast<uint8_t*>(nativeSelf->getItemData()),\n                                         static_cast<jlong>(nativeSelf->getItemDataSize()));\n     }\n \n     JNI_METHOD_ARG(void, setItemDataNative, jbyteArray data)\n     {\n         NATIVE_SELF;\n-        jbyte *nativeData = env->GetByteArrayElements(data, nullptr);\n-        nativeSelf->setItemData((uint8_t *) (nativeData), static_cast<uint64_t>(env->GetArrayLength(data)));\n+        jbyte* nativeData = env->GetByteArrayElements(data, nullptr);\n+        nativeSelf->setItemData((uint8_t*) (nativeData), static_cast<uint64_t>(env->GetArrayLength(data)));\n         env->ReleaseByteArrayElements(data, nativeData, 0);\n     }\n \ndiff --git a/srcs/api-java/cpp/ColourInformationPropertyJNI.cpp b/srcs/api-java/cpp/ColourInformationPropertyJNI.cpp\nindex 67abf31..86a5ec2 100644\n--- a/srcs/api-java/cpp/ColourInformationPropertyJNI.cpp\n+++ b/srcs/api-java/cpp/ColourInformationPropertyJNI.cpp\n@@ -26,7 +26,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::ColourInformationProperty(nativeHeif);\n+        auto* nativeObject = new HEIFPP::ColourInformationProperty(nativeHeif);\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n \n@@ -39,7 +39,7 @@ extern \"C\"\n     JNI_METHOD_ARG(void, setColourTypeNative, jstring javaString)\n     {\n         NATIVE_SELF;\n-        const char *nativeString                  = env->GetStringUTFChars(javaString, nullptr);\n+        const char* nativeString                  = env->GetStringUTFChars(javaString, nullptr);\n         nativeSelf->mColourInformation.colourType = HEIF::FourCC(nativeString);\n         env->ReleaseStringUTFChars(javaString, nativeString);\n     }\n@@ -102,7 +102,7 @@ extern \"C\"\n     JNI_METHOD_ARG(void, setICCProfileNative, jbyteArray data)\n     {\n         NATIVE_SELF;\n-        jbyte *nativeData                         = env->GetByteArrayElements(data, nullptr);\n+        jbyte* nativeData                         = env->GetByteArrayElements(data, nullptr);\n         auto dataSize                             = static_cast<uint32_t>(env->GetArrayLength(data));\n         nativeSelf->mColourInformation.iccProfile = HEIF::Array<uint8_t>(dataSize);\n         std::memcpy(nativeSelf->mColourInformation.iccProfile.elements, nativeData, dataSize);\ndiff --git a/srcs/api-java/cpp/ExifItemJNI.cpp b/srcs/api-java/cpp/ExifItemJNI.cpp\nindex e0955cb..21b7957 100644\n--- a/srcs/api-java/cpp/ExifItemJNI.cpp\n+++ b/srcs/api-java/cpp/ExifItemJNI.cpp\n@@ -23,22 +23,22 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::ExifItem(nativeHeif);\n+        auto* nativeObject = new HEIFPP::ExifItem(nativeHeif);\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n \n     JNI_METHOD(jobject, getItemDataNative)\n     {\n         NATIVE_SELF;\n-        return env->NewDirectByteBuffer(const_cast<uint8_t *>(nativeSelf->getData()),\n+        return env->NewDirectByteBuffer(const_cast<uint8_t*>(nativeSelf->getData()),\n                                         static_cast<jlong>(nativeSelf->getDataSize()));\n     }\n \n     JNI_METHOD_ARG(void, setItemDataNative, jbyteArray data)\n     {\n         NATIVE_SELF;\n-        jbyte *nativeData = env->GetByteArrayElements(data, nullptr);\n-        nativeSelf->setData((uint8_t *) nativeData, static_cast<uint64_t>(env->GetArrayLength(data)));\n+        jbyte* nativeData = env->GetByteArrayElements(data, nullptr);\n+        nativeSelf->setData((uint8_t*) nativeData, static_cast<uint64_t>(env->GetArrayLength(data)));\n         env->ReleaseByteArrayElements(data, nativeData, 0);\n     }\n }\ndiff --git a/srcs/api-java/cpp/GridImageItemJNI.cpp b/srcs/api-java/cpp/GridImageItemJNI.cpp\nindex 4252625..fccc92e 100644\n--- a/srcs/api-java/cpp/GridImageItemJNI.cpp\n+++ b/srcs/api-java/cpp/GridImageItemJNI.cpp\n@@ -24,7 +24,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::GridImageItem(nativeHeif);\n+        auto* nativeObject = new HEIFPP::GridImageItem(nativeHeif);\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n \n@@ -50,7 +50,7 @@ extern \"C\"\n     {\n         NATIVE_SELF;\n \n-        HEIFPP::ImageItem *imageItem = nullptr;\n+        HEIFPP::ImageItem* imageItem = nullptr;\n         CHECK_ERROR(nativeSelf->getImage(static_cast<uint32_t>(column), static_cast<uint32_t>(row), imageItem),\n                     \"getImage failed\");\n         return imageItem ? GET_JAVA_ITEM(imageItem) : nullptr;\ndiff --git a/srcs/api-java/cpp/HEIFJNI.cpp b/srcs/api-java/cpp/HEIFJNI.cpp\nindex a1ebda1..0d8263c 100644\n--- a/srcs/api-java/cpp/HEIFJNI.cpp\n+++ b/srcs/api-java/cpp/HEIFJNI.cpp\n@@ -36,7 +36,7 @@ extern \"C\"\n {\n     JNI_METHOD(void, createInstanceNative)\n     {\n-        auto *instance = new HEIFPP::Heif();\n+        auto* instance = new HEIFPP::Heif();\n         setNativeHandle(env, self, (jlong) instance);\n     }\n \n@@ -50,7 +50,7 @@ extern \"C\"\n     JNI_METHOD_ARG(void, loadNative, jstring filename, jint preloadMode)\n     {\n         NATIVE_HEIF(nativeHandle, self);\n-        const char *nativeFilename = env->GetStringUTFChars(filename, nullptr);\n+        const char* nativeFilename = env->GetStringUTFChars(filename, nullptr);\n \n         HEIFPP::Result error = nativeHandle->load(nativeFilename, static_cast<HEIFPP::Heif::PreloadMode>(preloadMode));\n         env->ReleaseStringUTFChars(filename, nativeFilename);\n@@ -60,7 +60,7 @@ extern \"C\"\n     JNI_METHOD_ARG(void, loadStreamNative, jobject stream, jint preloadMode)\n     {\n         NATIVE_HEIF(nativeHandle, self);\n-        auto *inputStream    = new InputStream(env, stream);\n+        auto* inputStream    = new InputStream(env, stream);\n         HEIFPP::Result error = nativeHandle->load(inputStream, static_cast<HEIFPP::Heif::PreloadMode>(preloadMode));\n         delete inputStream;\n         CHECK_ERROR(error, \"Loading failed\");\n@@ -69,7 +69,7 @@ extern \"C\"\n     JNI_METHOD_ARG(void, saveNative, jstring filename)\n     {\n         NATIVE_HEIF(nativeHandle, self);\n-        const char *nativeFilename = env->GetStringUTFChars(filename, nullptr);\n+        const char* nativeFilename = env->GetStringUTFChars(filename, nullptr);\n \n         HEIFPP::Result error = nativeHandle->save(nativeFilename);\n \n@@ -80,7 +80,7 @@ extern \"C\"\n     JNI_METHOD_ARG(void, saveStreamNative, jobject stream)\n     {\n         NATIVE_HEIF(nativeHandle, self);\n-        auto *outputStream   = new OutputStream(env, stream);\n+        auto* outputStream   = new OutputStream(env, stream);\n         HEIFPP::Result error = nativeHandle->save(outputStream);\n         delete outputStream;\n         CHECK_ERROR(error, \"Saving failed\");\n@@ -95,7 +95,7 @@ extern \"C\"\n     JNI_METHOD_ARG(jobject, getItemNative, jint itemIndex)\n     {\n         NATIVE_HEIF(nativeHandle, self);\n-        HEIFPP::Item *item = nativeHandle->getItem(static_cast<uint32_t>(itemIndex));\n+        HEIFPP::Item* item = nativeHandle->getItem(static_cast<uint32_t>(itemIndex));\n         return getJavaItem(env, self, item);\n     }\n \n@@ -108,7 +108,7 @@ extern \"C\"\n     JNI_METHOD_ARG(jobject, getImageNative, jint itemIndex)\n     {\n         NATIVE_HEIF(nativeHandle, self);\n-        HEIFPP::ImageItem *item = nativeHandle->getImage(static_cast<uint32_t>(itemIndex));\n+        HEIFPP::ImageItem* item = nativeHandle->getImage(static_cast<uint32_t>(itemIndex));\n         return getJavaItem(env, self, item);\n     }\n \n@@ -121,14 +121,14 @@ extern \"C\"\n     JNI_METHOD_ARG(jobject, getMasterImageNative, jint itemIndex)\n     {\n         NATIVE_HEIF(nativeHandle, self);\n-        HEIFPP::ImageItem *item = nativeHandle->getMasterImage(static_cast<uint32_t>(itemIndex));\n+        HEIFPP::ImageItem* item = nativeHandle->getMasterImage(static_cast<uint32_t>(itemIndex));\n         return getJavaItem(env, self, item);\n     }\n \n     JNI_METHOD_ARG(jint, getItemsOfTypeCountNative, jstring type)\n     {\n         NATIVE_HEIF(nativeHandle, self);\n-        const char *nativeString = env->GetStringUTFChars(type, nullptr);\n+        const char* nativeString = env->GetStringUTFChars(type, nullptr);\n \n         jint itemCount = static_cast<jint>(nativeHandle->getItemsOfTypeCount(HEIF::FourCC(nativeString)));\n \n@@ -139,7 +139,7 @@ extern \"C\"\n     JNI_METHOD_ARG(jobject, getItemOfTypeNative, jstring type, jint index)\n     {\n         NATIVE_HEIF(nativeHandle, self);\n-        const char *nativeString = env->GetStringUTFChars(type, nullptr);\n+        const char* nativeString = env->GetStringUTFChars(type, nullptr);\n         jobject javaObject       = getJavaItem(\n             env, self, nativeHandle->getItemOfType(HEIF::FourCC(nativeString), static_cast<uint32_t>(index)));\n         env->ReleaseStringUTFChars(type, nativeString);\n@@ -175,7 +175,7 @@ extern \"C\"\n     JNI_METHOD_ARG(void, addCompatibleBrandNative, jstring brand)\n     {\n         NATIVE_HEIF(nativeHandle, self);\n-        const char *nativeBrand = env->GetStringUTFChars(brand, nullptr);\n+        const char* nativeBrand = env->GetStringUTFChars(brand, nullptr);\n         nativeHandle->addCompatibleBrand(HEIF::FourCC(nativeBrand));\n         env->ReleaseStringUTFChars(brand, nativeBrand);\n     }\n@@ -183,7 +183,7 @@ extern \"C\"\n     JNI_METHOD_ARG(void, removeCompatibleBrandNative, jstring brand)\n     {\n         NATIVE_HEIF(nativeHandle, self);\n-        const char *nativeBrand = env->GetStringUTFChars(brand, nullptr);\n+        const char* nativeBrand = env->GetStringUTFChars(brand, nullptr);\n         nativeHandle->removeCompatibleBrand(HEIF::FourCC(nativeBrand));\n         env->ReleaseStringUTFChars(brand, nativeBrand);\n     }\n@@ -198,7 +198,7 @@ extern \"C\"\n     JNI_METHOD_ARG(void, setMajorBrandNative, jstring brand)\n     {\n         NATIVE_HEIF(nativeHandle, self);\n-        const char *nativeBrand = env->GetStringUTFChars(brand, nullptr);\n+        const char* nativeBrand = env->GetStringUTFChars(brand, nullptr);\n         nativeHandle->setMajorBrand(HEIF::FourCC(nativeBrand));\n         env->ReleaseStringUTFChars(brand, nativeBrand);\n     }\ndiff --git a/srcs/api-java/cpp/IdentityImageItemJNI.cpp b/srcs/api-java/cpp/IdentityImageItemJNI.cpp\nindex a7d40cf..adb8361 100644\n--- a/srcs/api-java/cpp/IdentityImageItemJNI.cpp\n+++ b/srcs/api-java/cpp/IdentityImageItemJNI.cpp\n@@ -25,7 +25,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::IdentityImageItem(nativeHeif);\n+        auto* nativeObject = new HEIFPP::IdentityImageItem(nativeHeif);\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n \ndiff --git a/srcs/api-java/cpp/ItemJNI.cpp b/srcs/api-java/cpp/ItemJNI.cpp\nindex c3f42d0..604c189 100644\n--- a/srcs/api-java/cpp/ItemJNI.cpp\n+++ b/srcs/api-java/cpp/ItemJNI.cpp\n@@ -21,7 +21,7 @@ extern \"C\"\n {\n     JNI_METHOD(jstring, getTypeNative)\n     {\n-        auto *instance = (HEIFPP::Item *) getNativeHandle(env, self);\n+        auto* instance = (HEIFPP::Item*) getNativeHandle(env, self);\n         return env->NewStringUTF(instance->getType().value);\n     }\n \ndiff --git a/srcs/api-java/cpp/MimeItemJNI.cpp b/srcs/api-java/cpp/MimeItemJNI.cpp\nindex d7b615e..2e3fc3d 100644\n--- a/srcs/api-java/cpp/MimeItemJNI.cpp\n+++ b/srcs/api-java/cpp/MimeItemJNI.cpp\n@@ -24,15 +24,15 @@ extern \"C\"\n     JNI_METHOD(jobject, getItemDataNative)\n     {\n         NATIVE_SELF;\n-        return env->NewDirectByteBuffer(const_cast<uint8_t *>(nativeSelf->getData()),\n+        return env->NewDirectByteBuffer(const_cast<uint8_t*>(nativeSelf->getData()),\n                                         static_cast<jlong>(nativeSelf->getDataSize()));\n     }\n \n     JNI_METHOD_ARG(void, setItemDataNative, jbyteArray data)\n     {\n         NATIVE_SELF;\n-        jbyte *nativeData = env->GetByteArrayElements(data, nullptr);\n-        nativeSelf->setData((uint8_t *) nativeData, static_cast<uint64_t>(env->GetArrayLength(data)));\n+        jbyte* nativeData = env->GetByteArrayElements(data, nullptr);\n+        nativeSelf->setData((uint8_t*) nativeData, static_cast<uint64_t>(env->GetArrayLength(data)));\n         env->ReleaseByteArrayElements(data, nativeData, 0);\n     }\n }\n\\ No newline at end of file\ndiff --git a/srcs/api-java/cpp/MirrorPropertyJNI.cpp b/srcs/api-java/cpp/MirrorPropertyJNI.cpp\nindex 3fc7d82..e536c8a 100644\n--- a/srcs/api-java/cpp/MirrorPropertyJNI.cpp\n+++ b/srcs/api-java/cpp/MirrorPropertyJNI.cpp\n@@ -25,7 +25,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::MirrorProperty(nativeHeif);\n+        auto* nativeObject = new HEIFPP::MirrorProperty(nativeHeif);\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n \ndiff --git a/srcs/api-java/cpp/OverlayImageItemJNI.cpp b/srcs/api-java/cpp/OverlayImageItemJNI.cpp\nindex 95e0c9c..9b8e641 100644\n--- a/srcs/api-java/cpp/OverlayImageItemJNI.cpp\n+++ b/srcs/api-java/cpp/OverlayImageItemJNI.cpp\n@@ -25,7 +25,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::OverlayImageItem(nativeHeif);\n+        auto* nativeObject = new HEIFPP::OverlayImageItem(nativeHeif);\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n \n@@ -46,7 +46,7 @@ extern \"C\"\n             env->GetMethodID(javaClass, \"createOverlayedImage\",\n                              \"(Lcom/nokia/heif/ImageItem;II)Lcom/nokia/heif/OverlayImageItem$OverlayedImage;\");\n         HEIF::Overlay::Offset overlayOffset;\n-        HEIFPP::ImageItem *image = nativeSelf->getImage(static_cast<uint32_t>(index), overlayOffset);\n+        HEIFPP::ImageItem* image = nativeSelf->getImage(static_cast<uint32_t>(index), overlayOffset);\n         env->DeleteLocalRef(javaClass);\n         return env->CallObjectMethod(self, createMethodId, getJavaItem(env, getJavaHEIF(env, self), image),\n                                      overlayOffset.horizontal, overlayOffset.vertical);\ndiff --git a/srcs/api-java/cpp/PixelAspectRatioJNI.cpp b/srcs/api-java/cpp/PixelAspectRatioJNI.cpp\nindex a57181f..c28de95 100644\n--- a/srcs/api-java/cpp/PixelAspectRatioJNI.cpp\n+++ b/srcs/api-java/cpp/PixelAspectRatioJNI.cpp\n@@ -25,7 +25,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::PixelAspectRatioProperty(nativeHeif);\n+        auto* nativeObject = new HEIFPP::PixelAspectRatioProperty(nativeHeif);\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n \ndiff --git a/srcs/api-java/cpp/PixelInformationPropertyJNI.cpp b/srcs/api-java/cpp/PixelInformationPropertyJNI.cpp\nindex 18bd016..e84bca1 100644\n--- a/srcs/api-java/cpp/PixelInformationPropertyJNI.cpp\n+++ b/srcs/api-java/cpp/PixelInformationPropertyJNI.cpp\n@@ -27,7 +27,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::PixelInformationProperty(nativeHeif);\n+        auto* nativeObject = new HEIFPP::PixelInformationProperty(nativeHeif);\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n \n@@ -42,7 +42,7 @@ extern \"C\"\n     JNI_METHOD_ARG(void, setPixelInformationNative, jbyteArray data)\n     {\n         NATIVE_SELF;\n-        jbyte *nativeData = env->GetByteArrayElements(data, nullptr);\n+        jbyte* nativeData = env->GetByteArrayElements(data, nullptr);\n         auto dataSize     = static_cast<uint32_t>(env->GetArrayLength(data));\n \n         nativeSelf->mPixelInformation.bitsPerChannel = HEIF::Array<uint8_t>(dataSize);\ndiff --git a/srcs/api-java/cpp/RawPropertyJNI.cpp b/srcs/api-java/cpp/RawPropertyJNI.cpp\nindex c676dc1..e941e65 100644\n--- a/srcs/api-java/cpp/RawPropertyJNI.cpp\n+++ b/srcs/api-java/cpp/RawPropertyJNI.cpp\n@@ -21,7 +21,7 @@ extern \"C\"\n {\n     JNI_METHOD(jstring, getRawTypeNative)\n     {\n-        auto *instance = (HEIFPP::RawProperty *) getNativeHandle(env, self);\n+        auto* instance = (HEIFPP::RawProperty*) getNativeHandle(env, self);\n         return env->NewStringUTF(instance->rawType().value);\n     }\n \n@@ -29,7 +29,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::RawProperty(nativeHeif);\n+        auto* nativeObject = new HEIFPP::RawProperty(nativeHeif);\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n \n@@ -43,24 +43,24 @@ extern \"C\"\n     JNI_METHOD(jobject, getDataNative)\n     {\n         NATIVE_SELF;\n-        const uint8_t *data;\n+        const uint8_t* data;\n         uint64_t length;\n         nativeSelf->getData(data, length);\n-        return env->NewDirectByteBuffer(const_cast<uint8_t *>(data), static_cast<jlong>(length));\n+        return env->NewDirectByteBuffer(const_cast<uint8_t*>(data), static_cast<jlong>(length));\n     }\n \n     JNI_METHOD_ARG(void, setDataNative, jbyteArray data)\n     {\n         NATIVE_SELF;\n-        jbyte *nativeData = env->GetByteArrayElements(data, nullptr);\n-        nativeSelf->setData((uint8_t *) (nativeData), static_cast<uint64_t>(env->GetArrayLength(data)));\n+        jbyte* nativeData = env->GetByteArrayElements(data, nullptr);\n+        nativeSelf->setData((uint8_t*) (nativeData), static_cast<uint64_t>(env->GetArrayLength(data)));\n         env->ReleaseByteArrayElements(data, nativeData, 0);\n     }\n \n     JNI_METHOD_ARG(void, setRawTypeNative, jstring type)\n     {\n         NATIVE_SELF;\n-        const char *nativeType = env->GetStringUTFChars(type, nullptr);\n+        const char* nativeType = env->GetStringUTFChars(type, nullptr);\n \n         HEIFPP::Result error = nativeSelf->setRawType(HEIF::FourCC(nativeType), false);\n         env->ReleaseStringUTFChars(type, nativeType);\ndiff --git a/srcs/api-java/cpp/RelativeLocationPropertyJNI.cpp b/srcs/api-java/cpp/RelativeLocationPropertyJNI.cpp\nindex a4ba9e5..31233af 100644\n--- a/srcs/api-java/cpp/RelativeLocationPropertyJNI.cpp\n+++ b/srcs/api-java/cpp/RelativeLocationPropertyJNI.cpp\n@@ -25,7 +25,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::RelativeLocationProperty(nativeHeif);\n+        auto* nativeObject = new HEIFPP::RelativeLocationProperty(nativeHeif);\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n \ndiff --git a/srcs/api-java/cpp/RotatePropertyJNI.cpp b/srcs/api-java/cpp/RotatePropertyJNI.cpp\nindex 0ecfb38..8d9ad66 100644\n--- a/srcs/api-java/cpp/RotatePropertyJNI.cpp\n+++ b/srcs/api-java/cpp/RotatePropertyJNI.cpp\n@@ -25,7 +25,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::RotateProperty(nativeHeif);\n+        auto* nativeObject = new HEIFPP::RotateProperty(nativeHeif);\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n \ndiff --git a/srcs/api-java/cpp/SampleJNI.cpp b/srcs/api-java/cpp/SampleJNI.cpp\nindex 3973094..169e772 100644\n--- a/srcs/api-java/cpp/SampleJNI.cpp\n+++ b/srcs/api-java/cpp/SampleJNI.cpp\n@@ -49,15 +49,15 @@ extern \"C\"\n     JNI_METHOD(jobject, getSampleDataNative)\n     {\n         NATIVE_SELF;\n-        return env->NewDirectByteBuffer(const_cast<uint8_t *>(nativeSelf->getSampleData()),\n+        return env->NewDirectByteBuffer(const_cast<uint8_t*>(nativeSelf->getSampleData()),\n                                         static_cast<jlong>(nativeSelf->getSampleDataSize()));\n     }\n \n     JNI_METHOD_ARG(void, setSampleDataNative, jbyteArray data)\n     {\n         NATIVE_SELF;\n-        jbyte *nativeData = env->GetByteArrayElements(data, nullptr);\n-        nativeSelf->setItemData((uint8_t *) nativeData, static_cast<uint64_t>(env->GetArrayLength(data)));\n+        jbyte* nativeData = env->GetByteArrayElements(data, nullptr);\n+        nativeSelf->setItemData((uint8_t*) nativeData, static_cast<uint64_t>(env->GetArrayLength(data)));\n         env->ReleaseByteArrayElements(data, nativeData, 0);\n     }\n \n@@ -176,7 +176,7 @@ extern \"C\"\n \n     JNI_METHOD(jstring, getTypeNative)\n     {\n-        auto *instance = (HEIFPP::Sample *) getNativeHandle(env, self);\n+        auto* instance = (HEIFPP::Sample*) getNativeHandle(env, self);\n         return env->NewStringUTF(instance->getType().value);\n     }\n }\ndiff --git a/srcs/api-java/cpp/StereoPairGroupJNI.cpp b/srcs/api-java/cpp/StereoPairGroupJNI.cpp\nindex be7e5cb..2e024ba 100644\n--- a/srcs/api-java/cpp/StereoPairGroupJNI.cpp\n+++ b/srcs/api-java/cpp/StereoPairGroupJNI.cpp\n@@ -25,7 +25,7 @@ extern \"C\"\n     {\n         UNUSED(self);\n         NATIVE_HEIF(nativeHeif, javaHEIF);\n-        auto *nativeObject = new HEIFPP::EntityGroup(nativeHeif, HEIF::FourCC(\"ster\"));\n+        auto* nativeObject = new HEIFPP::EntityGroup(nativeHeif, HEIF::FourCC(\"ster\"));\n         return reinterpret_cast<jlong>(nativeObject);\n     }\n }\ndiff --git a/srcs/common/avcdecoderconfigrecord.cpp b/srcs/common/avcdecoderconfigrecord.cpp\nindex 879c80a..76645fb 100644\n--- a/srcs/common/avcdecoderconfigrecord.cpp\n+++ b/srcs/common/avcdecoderconfigrecord.cpp\n@@ -37,7 +37,11 @@ AvcDecoderConfigurationRecord::AvcDecoderConfigurationRecord()\n \n bool AvcDecoderConfigurationRecord::makeConfigFromSPS(const Vector<uint8_t>& sps)\n {\n-    const Vector<uint8_t> rbspData = convertByteStreamToRBSP(sps);\n+    Vector<uint8_t> rbspData;\n+    if (convertByteStreamToRBSP(sps, rbspData) == false)\n+    {\n+        return false;\n+    }\n     BitStream bitstr(rbspData);\n     SPSConfigValues spsConfig;\n     // ignore the first byte indicating type\n@@ -375,4 +379,4 @@ void AvcDecoderConfigurationRecord::getConfigurationMap(ConfigurationMap& aMap)\n     aMap.clear();\n     aMap.insert({DecoderParameterType::AVC_SPS, move(sps)});\n     aMap.insert({DecoderParameterType::AVC_PPS, move(pps)});\n-}\n\\ No newline at end of file\n+}\ndiff --git a/srcs/common/hevcdecoderconfigrecord.cpp b/srcs/common/hevcdecoderconfigrecord.cpp\nindex f0012d3..475e1dc 100644\n--- a/srcs/common/hevcdecoderconfigrecord.cpp\n+++ b/srcs/common/hevcdecoderconfigrecord.cpp\n@@ -44,12 +44,16 @@ HevcDecoderConfigurationRecord::HevcDecoderConfigurationRecord()\n {\n }\n \n-void HevcDecoderConfigurationRecord::makeConfigFromSPS(const Vector<uint8_t> &srcSps)\n+bool HevcDecoderConfigurationRecord::makeConfigFromSPS(const Vector<uint8_t>& srcSps)\n {\n     unsigned int maxNumSubLayersMinus1;\n     Vector<bool> subLayerProfilePresentFlag(8, false);\n     Vector<bool> subLayerLevelPresentFlag(8, false);\n-    Vector<uint8_t> sps = convertByteStreamToRBSP(srcSps);\n+    Vector<uint8_t> sps;\n+    if (convertByteStreamToRBSP(srcSps, sps) == false)\n+    {\n+        return false;\n+    }\n \n     mAvgFrameRate      = 0;  // Unspecified average frame rate.\n     mConstantFrameRate = 0;\n@@ -129,6 +133,11 @@ void HevcDecoderConfigurationRecord::makeConfigFromSPS(const Vector<uint8_t> &sr\n     {\n         bitstr.readBits(1);  // separate_colour_plane_flag\n     }\n+    else if (mChromaFormat > 3)\n+    {\n+        return false;\n+    }\n+\n     mPicWidthInLumaSamples  = static_cast<uint16_t>(bitstr.readExpGolombCode());  // pic_width_in_luma_samples\n     mPicHeightInLumaSamples = static_cast<uint16_t>(bitstr.readExpGolombCode());  // pic_height_in_luma_samples\n \n@@ -153,18 +162,20 @@ void HevcDecoderConfigurationRecord::makeConfigFromSPS(const Vector<uint8_t> &sr\n \n     mMinSpatialSegmentationIdc = 0;\n     mParallelismType           = 0;\n+\n+    return true;\n }\n \n-void HevcDecoderConfigurationRecord::addNalUnit(const Vector<uint8_t> &nalUnit,\n+void HevcDecoderConfigurationRecord::addNalUnit(const Vector<uint8_t>& nalUnit,\n                                                 const HevcNalUnitType nalUnitType,\n                                                 const bool arrayCompleteness)\n {\n-    NALArray *nalArray = nullptr;\n+    NALArray* nalArray = nullptr;\n     Vector<uint8_t> tmpNalUnit;\n     unsigned int startCodeLen;\n \n     // find array for the given NAL unit type\n-    for (auto &i : mNalArray)\n+    for (auto& i : mNalArray)\n     {\n         if (static_cast<uint8_t>(nalUnitType) == static_cast<uint8_t>(i.nalUnitType))\n         {\n@@ -191,7 +202,7 @@ void HevcDecoderConfigurationRecord::addNalUnit(const Vector<uint8_t> &nalUnit,\n     nalArray->nalList.push_back(tmpNalUnit);\n }\n \n-void HevcDecoderConfigurationRecord::writeDecConfigRecord(ISOBMFF::BitStream &bitstr) const\n+void HevcDecoderConfigurationRecord::writeDecConfigRecord(ISOBMFF::BitStream& bitstr) const\n {\n     bitstr.writeBits(mConfigurationVersion, 8);\n     bitstr.writeBits(mGeneralProfileSpace, 2);\n@@ -220,13 +231,13 @@ void HevcDecoderConfigurationRecord::writeDecConfigRecord(ISOBMFF::BitStream &bi\n     bitstr.writeBits(mLengthSizeMinus1, 2);\n \n     bitstr.writeBits(mNalArray.size(), 8);\n-    for (const auto &i : mNalArray)\n+    for (const auto& i : mNalArray)\n     {\n         bitstr.writeBits(i.arrayCompleteness, 1);\n         bitstr.writeBits(0, 1);  // reserved = 0\n         bitstr.writeBits(static_cast<uint8_t>(i.nalUnitType), 6);\n         bitstr.writeBits(static_cast<unsigned int>(i.nalList.size()), 16);\n-        for (const auto &j : i.nalList)\n+        for (const auto& j : i.nalList)\n         {\n             bitstr.writeBits(static_cast<unsigned int>(j.size()), 16);\n             bitstr.write8BitsArray(j, j.size());  // write parameter set NAL unit\n@@ -234,7 +245,7 @@ void HevcDecoderConfigurationRecord::writeDecConfigRecord(ISOBMFF::BitStream &bi\n     }\n }\n \n-void HevcDecoderConfigurationRecord::parseConfig(ISOBMFF::BitStream &bitstr)\n+void HevcDecoderConfigurationRecord::parseConfig(ISOBMFF::BitStream& bitstr)\n {\n     unsigned int numOfArrays;\n \n@@ -288,10 +299,10 @@ void HevcDecoderConfigurationRecord::parseConfig(ISOBMFF::BitStream &bitstr)\n     }\n }\n \n-void HevcDecoderConfigurationRecord::getOneParameterSet(Vector<uint8_t> &byteStream,\n+void HevcDecoderConfigurationRecord::getOneParameterSet(Vector<uint8_t>& byteStream,\n                                                         const HevcNalUnitType nalUnitType) const\n {\n-    for (const auto &array : mNalArray)\n+    for (const auto& array : mNalArray)\n     {\n         if (array.nalUnitType == nalUnitType && array.nalList.size() > 0)\n         {\n@@ -307,14 +318,14 @@ void HevcDecoderConfigurationRecord::getOneParameterSet(Vector<uint8_t> &byteStr\n \n uint16_t HevcDecoderConfigurationRecord::getPicWidth() const\n {\n-    const uint16_t subWidthC[4] = {1, 2, 2, 1};\n-    return mPicWidthInLumaSamples - subWidthC[mChromaFormat] * (mConfWinLeftOffset + mConfWinRightOffset);\n+    const Vector<uint16_t> subWidthC = {1, 2, 2, 1};\n+    return mPicWidthInLumaSamples - subWidthC.at(mChromaFormat) * (mConfWinLeftOffset + mConfWinRightOffset);\n }\n \n uint16_t HevcDecoderConfigurationRecord::getPicHeight() const\n {\n-    const uint16_t subHeightC[4] = {1, 2, 1, 1};\n-    return mPicHeightInLumaSamples - subHeightC[mChromaFormat] * (mConfWinTopOffset + mConfWinBottomOffset);\n+    const Vector<uint16_t> subHeightC = {1, 2, 1, 1};\n+    return mPicHeightInLumaSamples - subHeightC.at(mChromaFormat) * (mConfWinTopOffset + mConfWinBottomOffset);\n }\n \n uint16_t HevcDecoderConfigurationRecord::getAvgFrameRate() const\n@@ -347,7 +358,7 @@ std::uint8_t HevcDecoderConfigurationRecord::getGeneralLevelIdc() const\n     return mGeneralLevelIdc;\n }\n \n-void HevcDecoderConfigurationRecord::getConfigurationMap(ConfigurationMap &aMap) const\n+void HevcDecoderConfigurationRecord::getConfigurationMap(ConfigurationMap& aMap) const\n {\n     Vector<std::uint8_t> sps;\n     Vector<std::uint8_t> pps;\ndiff --git a/srcs/common/hevcdecoderconfigrecord.hpp b/srcs/common/hevcdecoderconfigrecord.hpp\nindex e0e3cab..9d07237 100644\n--- a/srcs/common/hevcdecoderconfigrecord.hpp\n+++ b/srcs/common/hevcdecoderconfigrecord.hpp\n@@ -34,8 +34,9 @@ public:\n     /**\n      * Read configuration parameters from a SPS NAL unit.\n      * @param sps       Sequence Parameter Set data\n+     * @return True if success, false if there was no input data or processing SPS failed.\n      */\n-    void makeConfigFromSPS(const Vector<std::uint8_t> &sps);\n+    bool makeConfigFromSPS(const Vector<std::uint8_t>& sps);\n \n     /**\n      * Add NAL unit to the NAL unit array\n@@ -43,21 +44,21 @@ public:\n      * @param nalUnitType       Type of the NAL unit\n      * @param arrayCompleteness TBD\n      */\n-    void addNalUnit(const Vector<std::uint8_t> &sps, HevcNalUnitType nalUnitType, bool arrayCompleteness);\n+    void addNalUnit(const Vector<std::uint8_t>& sps, HevcNalUnitType nalUnitType, bool arrayCompleteness);\n \n     /**\n      * Serialize decoder configuration to ISOBMFF::BitStream.\n      * @param [in,out] bitstr Decoder configuration appended is appended to\n      * bitstr.\n      */\n-    void writeDecConfigRecord(ISOBMFF::BitStream &bitstr) const;\n+    void writeDecConfigRecord(ISOBMFF::BitStream& bitstr) const;\n \n     /**\n      * Deserialize HevcDecoderConfigurationRecord from ISOBMFF::BitStream\n      * @param [in,out] bitstr ISOBMFF::BitStream including decoder configuration\n      * data. ISOBMFF::BitStream position is modified accordingly.\n      */\n-    void parseConfig(ISOBMFF::BitStream &bitstr);\n+    void parseConfig(ISOBMFF::BitStream& bitstr);\n \n     /**\n      * @brief Append one parameter set of type nalUnitType.\n@@ -65,7 +66,7 @@ public:\n      * @param [in,out] byteStream  Vector where the parameter set is appended\n      * @param          nalUnitType NAL unit type to append\n      */\n-    void getOneParameterSet(Vector<std::uint8_t> &byteStream, HevcNalUnitType nalUnitType) const;\n+    void getOneParameterSet(Vector<std::uint8_t>& byteStream, HevcNalUnitType nalUnitType) const;\n \n     /**\n      * @pre makeConfigFromSPS has been called successfully.\n@@ -86,7 +87,7 @@ public:\n     std::uint16_t getAvgFrameRate() const;\n \n     /* @brief Returns configuration parameter map for this record */\n-    void getConfigurationMap(ConfigurationMap &aMap) const override;\n+    void getConfigurationMap(ConfigurationMap& aMap) const override;\n \n     /**\n      * @return Returns chroma_format_idc value.\ndiff --git a/srcs/common/iteminfobox.cpp b/srcs/common/iteminfobox.cpp\nindex e36bce9..078af0d 100644\n--- a/srcs/common/iteminfobox.cpp\n+++ b/srcs/common/iteminfobox.cpp\n@@ -302,9 +302,8 @@ void ItemInfoEntry::parseBox(ISOBMFF::BitStream& bitstr)\n         }\n         if (bitstr.numBytesLeft() > 0)  // This is an optional field\n         {\n-            auto* itemInfoExt = CUSTOM_NEW(FDItemInfoExtension, ());\n-            mItemInfoExtension.reset(itemInfoExt);\n-            itemInfoExt->parse(bitstr);\n+            mItemInfoExtension = makeCustomShared<FDItemInfoExtension>();\n+            mItemInfoExtension->parse(bitstr);\n         }\n     }\n     if (getVersion() >= 2)\ndiff --git a/srcs/common/nalutil.cpp b/srcs/common/nalutil.cpp\nindex f9e3a86..d1d8c6b 100644\n--- a/srcs/common/nalutil.cpp\n+++ b/srcs/common/nalutil.cpp\n@@ -33,21 +33,27 @@ unsigned int findStartCodeLen(const Vector<uint8_t>& data)\n     }\n }\n \n-Vector<uint8_t> convertByteStreamToRBSP(const Vector<uint8_t>& byteStr)\n+bool convertByteStreamToRBSP(const Vector<uint8_t>& byteStr, Vector<uint8_t>& output)\n {\n-    Vector<uint8_t> dest;\n     const size_t numBytesInNalUnit = byteStr.size();\n \n+    output.clear();\n     // this is a reasonable guess, as the result Vector can not be larger than the original\n-    dest.reserve(numBytesInNalUnit);\n+    output.reserve(numBytesInNalUnit);\n \n     // find start code end\n     uint32_t i = findStartCodeLen(byteStr);\n \n     // copy NALU header\n     static const size_t NALU_HEADER_LENGTH = 2;\n-    dest.insert(dest.end(), byteStr.cbegin() + static_cast<int32_t>(i),\n-                byteStr.cbegin() + static_cast<int32_t>(i) + NALU_HEADER_LENGTH);\n+\n+    if (i + NALU_HEADER_LENGTH > numBytesInNalUnit)\n+    {\n+        return false;\n+    }\n+\n+    output.insert(output.end(), byteStr.cbegin() + static_cast<int32_t>(i),\n+                  byteStr.cbegin() + static_cast<int32_t>(i) + NALU_HEADER_LENGTH);\n     i += NALU_HEADER_LENGTH;\n \n     // copy rest of the data while removing start code emulation prevention bytes\n@@ -91,7 +97,8 @@ Vector<uint8_t> convertByteStreamToRBSP(const Vector<uint8_t>& byteStr)\n             if (byte == 0x03)\n             {\n                 // skip copying 0x03\n-                dest.insert(dest.end(), byteStr.cbegin() + copyStartOffset, byteStr.cbegin() + static_cast<int32_t>(i));\n+                output.insert(output.end(), byteStr.cbegin() + copyStartOffset,\n+                              byteStr.cbegin() + static_cast<int32_t>(i));\n                 copyStartOffset = static_cast<int32_t>(i) + 1;\n                 // continue byte stream copying\n                 state = State::COPY_DATA;\n@@ -107,6 +114,6 @@ Vector<uint8_t> convertByteStreamToRBSP(const Vector<uint8_t>& byteStr)\n             break;\n         }\n     }\n-    dest.insert(dest.end(), byteStr.cbegin() + copyStartOffset, byteStr.cend());\n-    return dest;\n+    output.insert(output.end(), byteStr.cbegin() + copyStartOffset, byteStr.cend());\n+    return true;\n }\ndiff --git a/srcs/common/nalutil.hpp b/srcs/common/nalutil.hpp\nindex d70d6de..903e4de 100644\n--- a/srcs/common/nalutil.hpp\n+++ b/srcs/common/nalutil.hpp\n@@ -21,17 +21,18 @@\n  * @details Start code consists of any number of zero bytes (0x00) followed by a\n  * one (0x01) byte.\n  * @param srcData NAL data to search from\n- * @return Number of bytes in start code\n+ * @return Number of bytes in start code. 0 if a valid start code is not found.\n  */\n-unsigned int findStartCodeLen(const Vector<uint8_t> &data);\n+unsigned int findStartCodeLen(const Vector<uint8_t>& data);\n \n /**\n  * Convert byte stream to Raw Byte Sequence Payload (RBSP) by removing emulation\n  * prevention bytes (0x03).\n  * Possible start code will be stripped from beginning.\n  * @param byteStr ByteStream to convert.\n- * @return Data as RBSP without emulation prevention bytes and start code.\n+ * @param output Data as RBSP without emulation prevention bytes and start code.\n+ * @return False if NAL unit header was not found. True in success.\n  */\n-Vector<uint8_t> convertByteStreamToRBSP(const Vector<uint8_t> &byteStr);\n+bool convertByteStreamToRBSP(const Vector<uint8_t>& byteStr, Vector<uint8_t>& output);\n \n #endif  // NALUTIL_HPP\ndiff --git a/srcs/writer/writermetaimpl.cpp b/srcs/writer/writermetaimpl.cpp\nindex 8255af3..87e2632 100644\n--- a/srcs/writer/writermetaimpl.cpp\n+++ b/srcs/writer/writermetaimpl.cpp\n@@ -68,7 +68,10 @@ namespace HEIF\n                 {\n                     spsFound = true;\n                     configRecord.addNalUnit(nalVector, AvcNalUnitType::SPS);\n-                    configRecord.makeConfigFromSPS(nalVector);\n+                    if (configRecord.makeConfigFromSPS(nalVector) == false)\n+                    {\n+                        return ErrorCode::DECODER_CONFIGURATION_ERROR;\n+                    }\n                 }\n                 else\n                 {\n@@ -109,7 +112,10 @@ namespace HEIF\n                 {\n                     spsFound = true;\n                     configRecord.addNalUnit(nalVector, HevcNalUnitType::SPS, true);\n-                    configRecord.makeConfigFromSPS(nalVector);\n+                    if (configRecord.makeConfigFromSPS(nalVector) == false)\n+                    {\n+                        return ErrorCode::DECODER_CONFIGURATION_ERROR;\n+                    }\n                 }\n                 else\n                 {\n@@ -491,8 +497,8 @@ namespace HEIF\n             return ErrorCode::UNINITIALIZED;\n         }\n \n-        if ((iscl.targetWidthD == 0) || (iscl.targetWidthN == 0) ||\n-                (iscl.targetHeightD == 0) || (iscl.targetHeightN == 0))\n+        if ((iscl.targetWidthD == 0) || (iscl.targetWidthN == 0) || (iscl.targetHeightD == 0) ||\n+            (iscl.targetHeightN == 0))\n         {\n             return ErrorCode::INVALID_FUNCTION_PARAMETER;\n         }\ndiff --git a/srcs/writer/writermoovimpl.cpp b/srcs/writer/writermoovimpl.cpp\nindex 6c1bcda..c671cf8 100644\n--- a/srcs/writer/writermoovimpl.cpp\n+++ b/srcs/writer/writermoovimpl.cpp\n@@ -174,7 +174,10 @@ namespace HEIF\n                 {\n                     spsFound = true;\n                     decCfg.addNalUnit(nalVector, HevcNalUnitType::SPS, true);\n-                    decCfg.makeConfigFromSPS(nalVector);\n+                    if (decCfg.makeConfigFromSPS(nalVector) == false)\n+                    {\n+                        return ErrorCode::DECODER_CONFIGURATION_ERROR;\n+                    }\n                 }\n                 else\n                 {",
        "test_patch": ""
    },
    {
        "instance_id": "libxsmm-libxsmm-401",
        "repo": "libxsmm/libxsmm",
        "created_at": "2020-08-02T13:54:29+00:00",
        "problem_statement": "Attempting to free non-malloced address\n\n## System info\r\n\r\nUbuntu X64, gcc (Ubuntu 5.5.0-12ubuntu1), libxsmm_gemm_generator (latest master [ea905d0](https://github.com/hfp/libxsmm/commit/ea905d08037e5d7869ceab057f7a310ccb9199f3))\r\n\r\n## Command line\r\n\r\n./bin/libxsmm_gemm_generator sparse foo.c foo 16 16 16 32 0 32 1 1 1 1 hsw nopf DP @@\r\n\r\n## AddressSanitizer output\r\n\r\n```\r\n=================================================================\r\n==50898==ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x61600000fc80 in thread T0\r\n    #0 0x7f8141fc52ca in __interceptor_free (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x982ca)\r\n    #1 0x7f81419b3372 in fclose (/lib/x86_64-linux-gnu/libc.so.6+0x6d372)\r\n    #2 0x7f8141fc47cd in fclose (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x977cd)\r\n    #3 0x48ab16  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x48ab16)\r\n    #4 0x408ffe  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x408ffe)\r\n    #5 0x402920  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x402920)\r\n    #6 0x7f814196683f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)\r\n    #7 0x4035a8  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x4035a8)\r\n\r\n0x61600000fc80 is located 112 bytes inside of 3435973837-byte region [0x61600000fc10,0x6160cccdc8dd)\r\nASAN:SIGSEGV\r\n==50898==AddressSanitizer: while reporting a bug found another one. Ignoring.\r\n```\r\n\r\n## POC\r\n\r\n[free-none-libxsmm_gemm_generator-48ab16.zip](https://github.com/hfp/libxsmm/files/5012249/free-none-libxsmm_gemm_generator-48ab16.zip)",
        "hints_text": "hfp: Thank you for reporting this issue!\r\n\r\n( Just FYI, we make no promise regarding health of our master [although we continuously test our code even beyond the prominent Travis tests]. We treat our master-branch like a development branch and create releases at reasonable sync-points and with [hopefully] acceptable cadence. Let us know if this is not meeting your expectation so that we can rethink our QA. )\r\n\r\nFor our own records: are you relying on features in our master revision? It would be interesting to know! The main differentiation point of master vs. v1.16..1 at the moment are Intel Advanced Matrix Extensions.\n\nhfp: You have used our static code generation and there were two cases of errors: (1) the requested kernel-shape did not match the given sparse input-data, and (2) the given input data was plain invalid/malformed (matrix market file header did not match data records). Our static code generation is \"legacy functionality\" and we do not intent to carry it forward. We completely embrace JIT-code generation.\r\n\r\nRegarding the errors: we designed and implemented our code generation to deliver what the user requests (\"WYSIWYG\" with different perspective) and our API is not meant to perform deep validation and sanitation of user input. If you walk-in with fuzzed data, you can expect an error message at best. Also, LIBXSMM is quiet and intents to deliver error messages only when enabled (LIBXSMM_VERBOSE).\r\n\r\nHowever, we strive to support our users to incorporate LIBXSMM and to deliver a reasonable amount of runtime error handling, which is the reason we fixed the reported issue. We would also like to learn about your application if any of the above statements made you nervous. Thank you for your report and your dedicated contribution!",
        "base_commit": "61511606bfe4a0d528be68ef5ac33bef5577f7ca",
        "patch": "diff --git a/src/generator_spgemm.c b/src/generator_spgemm.c\nindex 40d69f9c2..1997ffaef 100644\n--- a/src/generator_spgemm.c\n+++ b/src/generator_spgemm.c\n@@ -261,6 +261,10 @@ void libxsmm_generator_spgemm( const char*                    i_file_out,\n     libxsmm_mmfunction_signature( &l_generated_code, i_routine_name, i_xgemm_desc );\n   }\n \n+  /* account for cases where requested shape does not match sparse data */\n+  l_column_count = i_xgemm_desc->n;\n+  l_row_count = i_xgemm_desc->m;\n+\n   /* check if generate to CSC */\n   /* @TODO, this i_is_csr is very hacky.... change it in future */\n   if ( (i_is_csr == 0) || (i_is_csr > 9) ) {\ndiff --git a/src/generator_spgemm_csc_reader.c b/src/generator_spgemm_csc_reader.c\nindex b7cc2aa2b..6c93fe670 100644\n--- a/src/generator_spgemm_csc_reader.c\n+++ b/src/generator_spgemm_csc_reader.c\n@@ -56,8 +56,8 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                                 unsigned int**          o_row_idx,\n                                 unsigned int**          o_column_idx,\n                                 double**                o_values,\n-                                unsigned int*           o_row_count,\n-                                unsigned int*           o_column_count,\n+                                unsigned int*           io_row_count,\n+                                unsigned int*           io_column_count,\n                                 unsigned int*           o_element_count ) {\n   FILE *l_csc_file_handle;\n   const unsigned int l_line_length = 512;\n@@ -75,7 +75,8 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n   while (fgets(l_line, l_line_length, l_csc_file_handle) != NULL) {\n     if ( strlen(l_line) == l_line_length ) {\n       free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n-      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+      *io_row_count = *io_column_count = *o_element_count = 0;\n+      *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n       fclose( l_csc_file_handle ); /* close mtx file */\n       LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_LEN );\n       return;\n@@ -86,18 +87,21 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n     } else {\n       /* if we are the first line after comment header, we allocate our data structures */\n       if ( l_header_read == 0 ) {\n-        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n-            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n+        unsigned int row_count, column_count;\n+        if (3 == sscanf(l_line, \"%u %u %u\", &row_count, &column_count, o_element_count) &&\n+            0 != row_count && 0 != column_count && 0 != *o_element_count)\n         {\n+          *io_column_count = LIBXSMM_MAX(*io_column_count, column_count);\n+          *io_row_count = LIBXSMM_MAX(*io_row_count, row_count);\n           /* allocate CSC data structure matching mtx file */\n           /* coverity[tainted_data] */\n           *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n+          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*io_column_count) + 1));\n           /* coverity[tainted_data] */\n           *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count));\n+          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*io_column_count));\n \n           /* check if mallocs were successful */\n           if ( ( *o_row_idx == NULL )      ||\n@@ -105,7 +109,8 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                ( *o_values == NULL )       ||\n                ( l_column_idx_id == NULL ) ) {\n             free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n-            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+            *io_row_count = *io_column_count = *o_element_count = 0;\n+            *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n             fclose(l_csc_file_handle); /* close mtx file */\n             LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n             return;\n@@ -115,15 +120,15 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n           /* coverity[tainted_data] */\n           memset(*o_row_idx, 0, sizeof(unsigned int) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          memset(*o_column_idx, 0, sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n+          memset(*o_column_idx, 0, sizeof(unsigned int) * ((size_t)(*io_column_count) + 1));\n           /* coverity[tainted_data] */\n           memset(*o_values, 0, sizeof(double) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          memset(l_column_idx_id, 0, sizeof(unsigned int) * (*o_column_count));\n+          memset(l_column_idx_id, 0, sizeof(unsigned int) * (*io_column_count));\n \n           /* init column idx */\n           /* coverity[tainted_data] */\n-          for (l_i = 0; l_i <= *o_column_count; ++l_i) {\n+          for (l_i = 0; l_i <= *io_column_count; ++l_i) {\n             (*o_column_idx)[l_i] = *o_element_count;\n           }\n           /* init */\n@@ -140,9 +145,13 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n         unsigned int l_row = 0, l_column = 0;\n         double l_value = 0;\n         /* read a line of content */\n-        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n+        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3\n+          || l_row > *io_row_count || l_column > *io_column_count\n+          || l_i >= *o_element_count )\n+        {\n           free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n-          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+          *io_row_count = *io_column_count = *o_element_count = 0;\n+          *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n           fclose(l_csc_file_handle); /* close mtx file */\n           LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_ELEMS );\n           return;\n@@ -168,14 +177,15 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n   /* check if we read a file which was consistent */\n   if ( l_i != (*o_element_count) ) {\n     free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n-    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+    *io_row_count = *io_column_count = *o_element_count = 0;\n+    *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n     LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_LEN );\n     return;\n   }\n \n   if ( l_column_idx_id != NULL ) {\n     /* let's handle empty columns */\n-    for ( l_i = 0; l_i < (*o_column_count); l_i++) {\n+    for ( l_i = 0; l_i < (*io_column_count); l_i++) {\n       if ( l_column_idx_id[l_i] == 0 ) {\n         (*o_column_idx)[l_i+1] = (*o_column_idx)[l_i];\n       }\ndiff --git a/src/generator_spgemm_csc_reader.h b/src/generator_spgemm_csc_reader.h\nindex ff207a675..896766bd9 100644\n--- a/src/generator_spgemm_csc_reader.h\n+++ b/src/generator_spgemm_csc_reader.h\n@@ -21,8 +21,8 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                                 unsigned int**          o_row_idx,\n                                 unsigned int**          o_column_idx,\n                                 double**                o_values,\n-                                unsigned int*           o_row_count,\n-                                unsigned int*           o_column_count,\n+                                unsigned int*           io_row_count,\n+                                unsigned int*           io_column_count,\n                                 unsigned int*           o_element_count );\n \n #endif /* GENERATOR_SPGEMM_CSC_READER_H */\ndiff --git a/src/generator_spgemm_csr_reader.c b/src/generator_spgemm_csr_reader.c\nindex c25da7f2d..7a7e47f5f 100644\n--- a/src/generator_spgemm_csr_reader.c\n+++ b/src/generator_spgemm_csr_reader.c\n@@ -17,8 +17,8 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                                 unsigned int**          o_row_idx,\n                                 unsigned int**          o_column_idx,\n                                 double**                o_values,\n-                                unsigned int*           o_row_count,\n-                                unsigned int*           o_column_count,\n+                                unsigned int*           io_row_count,\n+                                unsigned int*           io_column_count,\n                                 unsigned int*           o_element_count ) {\n   FILE *l_csr_file_handle;\n   const unsigned int l_line_length = 512;\n@@ -36,7 +36,8 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n   while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n     if ( strlen(l_line) == l_line_length ) {\n       free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n-      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+      *io_row_count = *io_column_count = *o_element_count = 0;\n+      *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n       fclose(l_csr_file_handle); /* close mtx file */\n       LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_LEN );\n       return;\n@@ -47,18 +48,21 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n     } else {\n       /* if we are the first line after comment header, we allocate our data structures */\n       if ( l_header_read == 0 ) {\n-        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n-            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n+        unsigned int row_count, column_count;\n+        if (3 == sscanf(l_line, \"%u %u %u\", &row_count, &column_count, o_element_count) &&\n+            0 != row_count && 0 != column_count && 0 != *o_element_count)\n         {\n+          *io_column_count = LIBXSMM_MAX(*io_column_count, column_count);\n+          *io_row_count = LIBXSMM_MAX(*io_row_count, row_count);\n           /* allocate CSC data-structure matching mtx file */\n           /* coverity[tainted_data] */\n           *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n+          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*io_row_count) + 1));\n           /* coverity[tainted_data] */\n           *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n+          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*io_row_count));\n \n           /* check if mallocs were successful */\n           if ( ( *o_row_idx == NULL )      ||\n@@ -66,7 +70,8 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                ( *o_values == NULL )       ||\n                ( l_row_idx_id == NULL ) ) {\n             free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n-            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+            *io_row_count = *io_column_count = *o_element_count = 0;\n+            *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n             fclose(l_csr_file_handle); /* close mtx file */\n             LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n             return;\n@@ -74,17 +79,17 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n \n           /* set everything to zero for init */\n           /* coverity[tainted_data] */\n-          memset(*o_row_idx, 0, sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n+          memset(*o_row_idx, 0, sizeof(unsigned int) * ((size_t)(*io_row_count) + 1));\n           /* coverity[tainted_data] */\n           memset(*o_column_idx, 0, sizeof(unsigned int) * (*o_element_count));\n           /* coverity[tainted_data] */\n           memset(*o_values, 0, sizeof(double) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          memset(l_row_idx_id, 0, sizeof(unsigned int) * (*o_row_count));\n+          memset(l_row_idx_id, 0, sizeof(unsigned int) * (*io_row_count));\n \n           /* init column idx */\n           /* coverity[tainted_data] */\n-          for ( l_i = 0; l_i <= *o_row_count; ++l_i )\n+          for ( l_i = 0; l_i <= *io_row_count; ++l_i )\n             (*o_row_idx)[l_i] = (*o_element_count);\n \n           /* init */\n@@ -101,9 +106,13 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n         unsigned int l_row = 0, l_column = 0;\n         double l_value = 0;\n         /* read a line of content */\n-        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n+        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3\n+          || l_row > * io_row_count || l_column > * io_column_count\n+          || l_i >= * o_element_count )\n+        {\n           free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n-          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+          *io_row_count = *io_column_count = *o_element_count = 0;\n+          *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n           fclose(l_csr_file_handle); /* close mtx file */\n           LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_ELEMS );\n           return;\n@@ -129,14 +138,15 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n   /* check if we read a file which was consistent */\n   if ( l_i != (*o_element_count) ) {\n     free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n-    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+    *io_row_count = *io_column_count = *o_element_count = 0;\n+    *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n     LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_LEN );\n     return;\n   }\n \n   if ( l_row_idx_id != NULL ) {\n     /* let's handle empty rows */\n-    for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n+    for ( l_i = 0; l_i < (*io_row_count); l_i++) {\n       if ( l_row_idx_id[l_i] == 0 ) {\n         (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n       }\ndiff --git a/src/generator_spgemm_csr_reader.h b/src/generator_spgemm_csr_reader.h\nindex a282870ff..1e852a77a 100644\n--- a/src/generator_spgemm_csr_reader.h\n+++ b/src/generator_spgemm_csr_reader.h\n@@ -21,8 +21,8 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                                 unsigned int**          o_row_idx,\n                                 unsigned int**          o_column_idx,\n                                 double**                o_values,\n-                                unsigned int*           o_row_count,\n-                                unsigned int*           o_column_count,\n+                                unsigned int*           io_row_count,\n+                                unsigned int*           io_column_count,\n                                 unsigned int*           o_element_count );\n \n #endif /* GENERATOR_SPGEMM_CSR_READER_H */\ndiff --git a/version.txt b/version.txt\nindex 33e389bc4..fbfb00a35 100644\n--- a/version.txt\n+++ b/version.txt\n@@ -1 +1 @@\n-master-1.16.1-112\n+master-1.16.1-115",
        "test_patch": ""
    },
    {
        "instance_id": "libxsmm-libxsmm-400",
        "repo": "libxsmm/libxsmm",
        "created_at": "2020-08-02T13:51:26+00:00",
        "problem_statement": "Alloc dealloc mismatch\n\n## System info\r\n\r\nUbuntu X64, gcc (Ubuntu 5.5.0-12ubuntu1), libxsmm_gemm_generator (latest master [ea905d0](https://github.com/hfp/libxsmm/commit/ea905d08037e5d7869ceab057f7a310ccb9199f3))\r\n\r\n## Command line\r\n\r\n./bin/libxsmm_gemm_generator sparse foo.c foo 16 16 16 32 0 32 1 1 1 1 hsw nopf DP @@\r\n\r\n## AddressSanitizer output\r\n\r\n```\r\n=================================================================\r\n==9028==ERROR: AddressSanitizer: alloc-dealloc-mismatch (INVALID vs free) on 0x61300000de80\r\n    #0 0x7fd31a8032ca in __interceptor_free (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x982ca)\r\n    #1 0x408d74  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x408d74)\r\n    #2 0x402920  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x402920)\r\n    #3 0x7fd31a1a483f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)\r\n    #4 0x4035a8  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x4035a8)\r\n\r\n0x61300000de80 is located 0 bytes inside of 340-byte region [0x61300000de80,0x61300000dfd4)\r\nASAN:SIGSEGV\r\n==9028==AddressSanitizer: while reporting a bug found another one. Ignoring.\r\n```\r\n\r\n## POC\r\n\r\n[alloc-dealloc-mismatch-libxsmm_gemm_generator-408d74.zip](https://github.com/hfp/libxsmm/files/5012243/alloc-dealloc-mismatch-libxsmm_gemm_generator-408d74.zip)",
        "hints_text": "hfp: Thank you for reporting this issue!\r\n\r\n( Just FYI, we make no promise regarding health of our master [although we continuously test our code even beyond the prominent Travis tests]. We treat our master-branch like a development branch and create releases at reasonable sync-points and with [hopefully] acceptable cadence. Let us know if this is not meeting your expectation so that we can rethink our QA. )\r\n\r\nFor our own records: are you relying on features in our master revision? It would be interesting to know! The main differentiation point of master vs. v1.16..1 at the moment are Intel Advanced Matrix Extensions.\n\nseviezhou: Actually, I do not rely on the new features of the master branch, just think that the master is the newest one and I want to try it.\n\nhfp: You are welcome, and it is much appreciated that you report your findings here!\r\n\r\nThe last we want is defects reported upstream first (\"broken package\") and causing all issue pages to echo/replicate a defect about a \"broken\" LIBXSMM. Also, libxsmm_gemm_generator is an example code that is like \"legacy code\" able to generate *static* code that is supposed to correspond with our JIT-generated code. We may need to remove this code-generator in the future since it is *exotic* rather than related to our intended use case.\n\nhfp: You have used our static code generation and there were two cases of errors: (1) the requested kernel-shape did not match the given sparse input-data, and (2) the given input data was plain invalid/malformed (matrix market file header did not match data records). Our static code generation is \"legacy functionality\" and we do not intent to carry it forward. We completely embrace JIT-code generation.\r\n\r\nRegarding the errors: we designed and implemented our code generation to deliver what the user requests (\"WYSIWYG\" with different perspective) and our API is not meant to perform deep validation and sanitation of user input. If you walk-in with fuzzed data, you can expect an error message at best. Also, LIBXSMM is quiet and intents to deliver error messages only when enabled (LIBXSMM_VERBOSE).\r\n\r\nHowever, we strive to support our users to incorporate LIBXSMM and to deliver a reasonable amount of runtime error handling, which is the reason we fixed the reported issue. We would also like to learn about your application if any of the above statements made you nervous. Thank you for your report and your dedicated contribution!",
        "base_commit": "61511606bfe4a0d528be68ef5ac33bef5577f7ca",
        "patch": "diff --git a/src/generator_spgemm.c b/src/generator_spgemm.c\nindex 40d69f9c2..1997ffaef 100644\n--- a/src/generator_spgemm.c\n+++ b/src/generator_spgemm.c\n@@ -261,6 +261,10 @@ void libxsmm_generator_spgemm( const char*                    i_file_out,\n     libxsmm_mmfunction_signature( &l_generated_code, i_routine_name, i_xgemm_desc );\n   }\n \n+  /* account for cases where requested shape does not match sparse data */\n+  l_column_count = i_xgemm_desc->n;\n+  l_row_count = i_xgemm_desc->m;\n+\n   /* check if generate to CSC */\n   /* @TODO, this i_is_csr is very hacky.... change it in future */\n   if ( (i_is_csr == 0) || (i_is_csr > 9) ) {\ndiff --git a/src/generator_spgemm_csc_reader.c b/src/generator_spgemm_csc_reader.c\nindex b7cc2aa2b..6c93fe670 100644\n--- a/src/generator_spgemm_csc_reader.c\n+++ b/src/generator_spgemm_csc_reader.c\n@@ -56,8 +56,8 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                                 unsigned int**          o_row_idx,\n                                 unsigned int**          o_column_idx,\n                                 double**                o_values,\n-                                unsigned int*           o_row_count,\n-                                unsigned int*           o_column_count,\n+                                unsigned int*           io_row_count,\n+                                unsigned int*           io_column_count,\n                                 unsigned int*           o_element_count ) {\n   FILE *l_csc_file_handle;\n   const unsigned int l_line_length = 512;\n@@ -75,7 +75,8 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n   while (fgets(l_line, l_line_length, l_csc_file_handle) != NULL) {\n     if ( strlen(l_line) == l_line_length ) {\n       free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n-      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+      *io_row_count = *io_column_count = *o_element_count = 0;\n+      *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n       fclose( l_csc_file_handle ); /* close mtx file */\n       LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_LEN );\n       return;\n@@ -86,18 +87,21 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n     } else {\n       /* if we are the first line after comment header, we allocate our data structures */\n       if ( l_header_read == 0 ) {\n-        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n-            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n+        unsigned int row_count, column_count;\n+        if (3 == sscanf(l_line, \"%u %u %u\", &row_count, &column_count, o_element_count) &&\n+            0 != row_count && 0 != column_count && 0 != *o_element_count)\n         {\n+          *io_column_count = LIBXSMM_MAX(*io_column_count, column_count);\n+          *io_row_count = LIBXSMM_MAX(*io_row_count, row_count);\n           /* allocate CSC data structure matching mtx file */\n           /* coverity[tainted_data] */\n           *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n+          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*io_column_count) + 1));\n           /* coverity[tainted_data] */\n           *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count));\n+          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*io_column_count));\n \n           /* check if mallocs were successful */\n           if ( ( *o_row_idx == NULL )      ||\n@@ -105,7 +109,8 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                ( *o_values == NULL )       ||\n                ( l_column_idx_id == NULL ) ) {\n             free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n-            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+            *io_row_count = *io_column_count = *o_element_count = 0;\n+            *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n             fclose(l_csc_file_handle); /* close mtx file */\n             LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n             return;\n@@ -115,15 +120,15 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n           /* coverity[tainted_data] */\n           memset(*o_row_idx, 0, sizeof(unsigned int) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          memset(*o_column_idx, 0, sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n+          memset(*o_column_idx, 0, sizeof(unsigned int) * ((size_t)(*io_column_count) + 1));\n           /* coverity[tainted_data] */\n           memset(*o_values, 0, sizeof(double) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          memset(l_column_idx_id, 0, sizeof(unsigned int) * (*o_column_count));\n+          memset(l_column_idx_id, 0, sizeof(unsigned int) * (*io_column_count));\n \n           /* init column idx */\n           /* coverity[tainted_data] */\n-          for (l_i = 0; l_i <= *o_column_count; ++l_i) {\n+          for (l_i = 0; l_i <= *io_column_count; ++l_i) {\n             (*o_column_idx)[l_i] = *o_element_count;\n           }\n           /* init */\n@@ -140,9 +145,13 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n         unsigned int l_row = 0, l_column = 0;\n         double l_value = 0;\n         /* read a line of content */\n-        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n+        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3\n+          || l_row > *io_row_count || l_column > *io_column_count\n+          || l_i >= *o_element_count )\n+        {\n           free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n-          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+          *io_row_count = *io_column_count = *o_element_count = 0;\n+          *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n           fclose(l_csc_file_handle); /* close mtx file */\n           LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_ELEMS );\n           return;\n@@ -168,14 +177,15 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n   /* check if we read a file which was consistent */\n   if ( l_i != (*o_element_count) ) {\n     free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n-    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+    *io_row_count = *io_column_count = *o_element_count = 0;\n+    *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n     LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_LEN );\n     return;\n   }\n \n   if ( l_column_idx_id != NULL ) {\n     /* let's handle empty columns */\n-    for ( l_i = 0; l_i < (*o_column_count); l_i++) {\n+    for ( l_i = 0; l_i < (*io_column_count); l_i++) {\n       if ( l_column_idx_id[l_i] == 0 ) {\n         (*o_column_idx)[l_i+1] = (*o_column_idx)[l_i];\n       }\ndiff --git a/src/generator_spgemm_csc_reader.h b/src/generator_spgemm_csc_reader.h\nindex ff207a675..896766bd9 100644\n--- a/src/generator_spgemm_csc_reader.h\n+++ b/src/generator_spgemm_csc_reader.h\n@@ -21,8 +21,8 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                                 unsigned int**          o_row_idx,\n                                 unsigned int**          o_column_idx,\n                                 double**                o_values,\n-                                unsigned int*           o_row_count,\n-                                unsigned int*           o_column_count,\n+                                unsigned int*           io_row_count,\n+                                unsigned int*           io_column_count,\n                                 unsigned int*           o_element_count );\n \n #endif /* GENERATOR_SPGEMM_CSC_READER_H */\ndiff --git a/src/generator_spgemm_csr_reader.c b/src/generator_spgemm_csr_reader.c\nindex c25da7f2d..7a7e47f5f 100644\n--- a/src/generator_spgemm_csr_reader.c\n+++ b/src/generator_spgemm_csr_reader.c\n@@ -17,8 +17,8 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                                 unsigned int**          o_row_idx,\n                                 unsigned int**          o_column_idx,\n                                 double**                o_values,\n-                                unsigned int*           o_row_count,\n-                                unsigned int*           o_column_count,\n+                                unsigned int*           io_row_count,\n+                                unsigned int*           io_column_count,\n                                 unsigned int*           o_element_count ) {\n   FILE *l_csr_file_handle;\n   const unsigned int l_line_length = 512;\n@@ -36,7 +36,8 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n   while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n     if ( strlen(l_line) == l_line_length ) {\n       free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n-      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+      *io_row_count = *io_column_count = *o_element_count = 0;\n+      *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n       fclose(l_csr_file_handle); /* close mtx file */\n       LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_LEN );\n       return;\n@@ -47,18 +48,21 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n     } else {\n       /* if we are the first line after comment header, we allocate our data structures */\n       if ( l_header_read == 0 ) {\n-        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n-            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n+        unsigned int row_count, column_count;\n+        if (3 == sscanf(l_line, \"%u %u %u\", &row_count, &column_count, o_element_count) &&\n+            0 != row_count && 0 != column_count && 0 != *o_element_count)\n         {\n+          *io_column_count = LIBXSMM_MAX(*io_column_count, column_count);\n+          *io_row_count = LIBXSMM_MAX(*io_row_count, row_count);\n           /* allocate CSC data-structure matching mtx file */\n           /* coverity[tainted_data] */\n           *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n+          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*io_row_count) + 1));\n           /* coverity[tainted_data] */\n           *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n+          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*io_row_count));\n \n           /* check if mallocs were successful */\n           if ( ( *o_row_idx == NULL )      ||\n@@ -66,7 +70,8 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                ( *o_values == NULL )       ||\n                ( l_row_idx_id == NULL ) ) {\n             free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n-            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+            *io_row_count = *io_column_count = *o_element_count = 0;\n+            *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n             fclose(l_csr_file_handle); /* close mtx file */\n             LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n             return;\n@@ -74,17 +79,17 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n \n           /* set everything to zero for init */\n           /* coverity[tainted_data] */\n-          memset(*o_row_idx, 0, sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n+          memset(*o_row_idx, 0, sizeof(unsigned int) * ((size_t)(*io_row_count) + 1));\n           /* coverity[tainted_data] */\n           memset(*o_column_idx, 0, sizeof(unsigned int) * (*o_element_count));\n           /* coverity[tainted_data] */\n           memset(*o_values, 0, sizeof(double) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          memset(l_row_idx_id, 0, sizeof(unsigned int) * (*o_row_count));\n+          memset(l_row_idx_id, 0, sizeof(unsigned int) * (*io_row_count));\n \n           /* init column idx */\n           /* coverity[tainted_data] */\n-          for ( l_i = 0; l_i <= *o_row_count; ++l_i )\n+          for ( l_i = 0; l_i <= *io_row_count; ++l_i )\n             (*o_row_idx)[l_i] = (*o_element_count);\n \n           /* init */\n@@ -101,9 +106,13 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n         unsigned int l_row = 0, l_column = 0;\n         double l_value = 0;\n         /* read a line of content */\n-        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n+        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3\n+          || l_row > * io_row_count || l_column > * io_column_count\n+          || l_i >= * o_element_count )\n+        {\n           free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n-          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+          *io_row_count = *io_column_count = *o_element_count = 0;\n+          *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n           fclose(l_csr_file_handle); /* close mtx file */\n           LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_ELEMS );\n           return;\n@@ -129,14 +138,15 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n   /* check if we read a file which was consistent */\n   if ( l_i != (*o_element_count) ) {\n     free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n-    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n+    *io_row_count = *io_column_count = *o_element_count = 0;\n+    *o_row_idx = *o_column_idx = NULL; *o_values = NULL;\n     LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_LEN );\n     return;\n   }\n \n   if ( l_row_idx_id != NULL ) {\n     /* let's handle empty rows */\n-    for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n+    for ( l_i = 0; l_i < (*io_row_count); l_i++) {\n       if ( l_row_idx_id[l_i] == 0 ) {\n         (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n       }\ndiff --git a/src/generator_spgemm_csr_reader.h b/src/generator_spgemm_csr_reader.h\nindex a282870ff..1e852a77a 100644\n--- a/src/generator_spgemm_csr_reader.h\n+++ b/src/generator_spgemm_csr_reader.h\n@@ -21,8 +21,8 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                                 unsigned int**          o_row_idx,\n                                 unsigned int**          o_column_idx,\n                                 double**                o_values,\n-                                unsigned int*           o_row_count,\n-                                unsigned int*           o_column_count,\n+                                unsigned int*           io_row_count,\n+                                unsigned int*           io_column_count,\n                                 unsigned int*           o_element_count );\n \n #endif /* GENERATOR_SPGEMM_CSR_READER_H */\ndiff --git a/version.txt b/version.txt\nindex 33e389bc4..fbfb00a35 100644\n--- a/version.txt\n+++ b/version.txt\n@@ -1 +1 @@\n-master-1.16.1-112\n+master-1.16.1-115",
        "test_patch": ""
    },
    {
        "instance_id": "libxsmm-libxsmm-399",
        "repo": "libxsmm/libxsmm",
        "created_at": "2020-08-02T13:46:09+00:00",
        "problem_statement": "Attempting to free non-malloced address\n\n## System info\r\n\r\nUbuntu X64, gcc (Ubuntu 5.5.0-12ubuntu1), libxsmm_gemm_generator (latest master [ea905d0](https://github.com/hfp/libxsmm/commit/ea905d08037e5d7869ceab057f7a310ccb9199f3))\r\n\r\n## Command line\r\n\r\n./bin/libxsmm_gemm_generator sparse foo.c foo 16 16 16 32 0 32 1 1 1 1 hsw nopf DP @@\r\n\r\n## AddressSanitizer output\r\n\r\n```\r\n=================================================================\r\n==75976==ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x62100001cd00 in thread T0\r\n    #0 0x7f07849d12ca in __interceptor_free (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x982ca)\r\n    #1 0x7f07843cd55a in _IO_setb (/lib/x86_64-linux-gnu/libc.so.6+0x7b55a)\r\n    #2 0x7f07843cb8fd in _IO_file_close_it (/lib/x86_64-linux-gnu/libc.so.6+0x798fd)\r\n    #3 0x7f07843bf3fe in fclose (/lib/x86_64-linux-gnu/libc.so.6+0x6d3fe)\r\n    #4 0x7f07849d07cd in fclose (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x977cd)\r\n    #5 0x48a4bd  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x48a4bd)\r\n    #6 0x408ffe  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x408ffe)\r\n    #7 0x402920  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x402920)\r\n    #8 0x7f078437283f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)\r\n    #9 0x4035a8  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x4035a8)\r\n\r\n0x62100001cd00 is located 240 bytes inside of 203034817-byte region [0x62100001cc10,0x62100c1bdcd1)\r\n==75976==AddressSanitizer CHECK failed: ../../../../src/libsanitizer/asan/asan_allocator2.cc:186 \"((res.trace)) != (0)\" (0x0, 0x0)\r\n    #0 0x7f07849d9631  (/usr/lib/x86_64-linux-gnu/libasan.so.2+0xa0631)\r\n    #1 0x7f07849de5e3 in __sanitizer::CheckFailed(char const*, int, char const*, unsigned long long, unsigned long long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0xa55e3)\r\n    #2 0x7f078495676c  (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x1d76c)\r\n    #3 0x7f078495761e  (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x1e61e)\r\n    #4 0x7f07849d6380  (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x9d380)\r\n    #5 0x7f07849d7727  (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x9e727)\r\n    #6 0x7f078495a617  (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x21617)\r\n    #7 0x7f07849d129d in __interceptor_free (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x9829d)\r\n    #8 0x7f07843cd55a in _IO_setb (/lib/x86_64-linux-gnu/libc.so.6+0x7b55a)\r\n    #9 0x7f07843cb8fd in _IO_file_close_it (/lib/x86_64-linux-gnu/libc.so.6+0x798fd)\r\n    #10 0x7f07843bf3fe in fclose (/lib/x86_64-linux-gnu/libc.so.6+0x6d3fe)\r\n    #11 0x7f07849d07cd in fclose (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x977cd)\r\n    #12 0x48a4bd  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x48a4bd)\r\n    #13 0x408ffe  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x408ffe)\r\n    #14 0x402920  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x402920)\r\n    #15 0x7f078437283f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)\r\n    #16 0x4035a8  (/home/seviezhou/libxsmm/bin/libxsmm_gemm_generator+0x4035a8)\r\n\r\n```\r\n\r\n## POC\r\n\r\n[free-none-libxsmm_gemm_generator.zip](https://github.com/hfp/libxsmm/files/5012232/free-none-libxsmm_gemm_generator.zip)",
        "hints_text": "hfp: Thank you for reporting this issue!\r\n\r\n( Just FYI, we make no promise regarding health of our master [although we continuously test our code even beyond the prominent Travis tests]. We treat our master-branch like a development branch and create releases at reasonable sync-points and with [hopefully] acceptable cadence. Let us know if this is not meeting your expectation so that we can rethink our QA. )\r\n\r\nFor our own records: are you relying on features in our master revision? It would be interesting to know! The main differentiation point of master vs. v1.16..1 at the moment are Intel Advanced Matrix Extensions.\n\nhfp: You have used our static code generation and there were two cases of errors: (1) the requested kernel-shape did not match the given sparse input-data, and (2) the given input data was plain invalid/malformed (matrix market file header did not match data records). Our static code generation is \"legacy functionality\" and we do not intent to carry it forward. We completely embrace JIT-code generation.\r\n\r\nRegarding the errors: we designed and implemented our code generation to deliver what the user requests (\"WYSIWYG\" with different perspective) and our API is not meant to perform deep validation and sanitation of user input. If you walk-in with fuzzed data, you can expect an error message at best. Also, LIBXSMM is quiet and intents to deliver error messages only when enabled (LIBXSMM_VERBOSE).\r\n\r\nHowever, we strive to support our users to incorporate LIBXSMM and to deliver a reasonable amount of runtime error handling, which is the reason we fixed the reported issue. We would also like to learn about your application if any of the above statements made you nervous. Thank you for your report and your dedicated contribution!",
        "base_commit": "61511606bfe4a0d528be68ef5ac33bef5577f7ca",
        "patch": "diff --git a/src/generator_spgemm.c b/src/generator_spgemm.c\nindex 40d69f9c2..1997ffaef 100644\n--- a/src/generator_spgemm.c\n+++ b/src/generator_spgemm.c\n@@ -261,6 +261,10 @@ void libxsmm_generator_spgemm( const char*                    i_file_out,\n     libxsmm_mmfunction_signature( &l_generated_code, i_routine_name, i_xgemm_desc );\n   }\n \n+  /* account for cases where requested shape does not match sparse data */\n+  l_column_count = i_xgemm_desc->n;\n+  l_row_count = i_xgemm_desc->m;\n+\n   /* check if generate to CSC */\n   /* @TODO, this i_is_csr is very hacky.... change it in future */\n   if ( (i_is_csr == 0) || (i_is_csr > 9) ) {\ndiff --git a/src/generator_spgemm_csc_reader.c b/src/generator_spgemm_csc_reader.c\nindex b7cc2aa2b..a3d2c8e76 100644\n--- a/src/generator_spgemm_csc_reader.c\n+++ b/src/generator_spgemm_csc_reader.c\n@@ -56,8 +56,8 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                                 unsigned int**          o_row_idx,\n                                 unsigned int**          o_column_idx,\n                                 double**                o_values,\n-                                unsigned int*           o_row_count,\n-                                unsigned int*           o_column_count,\n+                                unsigned int*           io_row_count,\n+                                unsigned int*           io_column_count,\n                                 unsigned int*           o_element_count ) {\n   FILE *l_csc_file_handle;\n   const unsigned int l_line_length = 512;\n@@ -86,18 +86,21 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n     } else {\n       /* if we are the first line after comment header, we allocate our data structures */\n       if ( l_header_read == 0 ) {\n-        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n-            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n+        unsigned int row_count, column_count;\n+        if (3 == sscanf(l_line, \"%u %u %u\", &row_count, &column_count, o_element_count) &&\n+            0 != row_count && 0 != column_count && 0 != *o_element_count)\n         {\n+          *io_column_count = LIBXSMM_MAX(*io_column_count, column_count);\n+          *io_row_count = LIBXSMM_MAX(*io_row_count, row_count);\n           /* allocate CSC data structure matching mtx file */\n           /* coverity[tainted_data] */\n           *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n+          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*io_column_count) + 1));\n           /* coverity[tainted_data] */\n           *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count));\n+          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*io_column_count));\n \n           /* check if mallocs were successful */\n           if ( ( *o_row_idx == NULL )      ||\n@@ -115,15 +118,15 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n           /* coverity[tainted_data] */\n           memset(*o_row_idx, 0, sizeof(unsigned int) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          memset(*o_column_idx, 0, sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n+          memset(*o_column_idx, 0, sizeof(unsigned int) * ((size_t)(*io_column_count) + 1));\n           /* coverity[tainted_data] */\n           memset(*o_values, 0, sizeof(double) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          memset(l_column_idx_id, 0, sizeof(unsigned int) * (*o_column_count));\n+          memset(l_column_idx_id, 0, sizeof(unsigned int) * (*io_column_count));\n \n           /* init column idx */\n           /* coverity[tainted_data] */\n-          for (l_i = 0; l_i <= *o_column_count; ++l_i) {\n+          for (l_i = 0; l_i <= *io_column_count; ++l_i) {\n             (*o_column_idx)[l_i] = *o_element_count;\n           }\n           /* init */\n@@ -175,7 +178,7 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n \n   if ( l_column_idx_id != NULL ) {\n     /* let's handle empty columns */\n-    for ( l_i = 0; l_i < (*o_column_count); l_i++) {\n+    for ( l_i = 0; l_i < (*io_column_count); l_i++) {\n       if ( l_column_idx_id[l_i] == 0 ) {\n         (*o_column_idx)[l_i+1] = (*o_column_idx)[l_i];\n       }\ndiff --git a/src/generator_spgemm_csc_reader.h b/src/generator_spgemm_csc_reader.h\nindex ff207a675..896766bd9 100644\n--- a/src/generator_spgemm_csc_reader.h\n+++ b/src/generator_spgemm_csc_reader.h\n@@ -21,8 +21,8 @@ void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                                 unsigned int**          o_row_idx,\n                                 unsigned int**          o_column_idx,\n                                 double**                o_values,\n-                                unsigned int*           o_row_count,\n-                                unsigned int*           o_column_count,\n+                                unsigned int*           io_row_count,\n+                                unsigned int*           io_column_count,\n                                 unsigned int*           o_element_count );\n \n #endif /* GENERATOR_SPGEMM_CSC_READER_H */\ndiff --git a/src/generator_spgemm_csr_reader.c b/src/generator_spgemm_csr_reader.c\nindex c25da7f2d..0577b9416 100644\n--- a/src/generator_spgemm_csr_reader.c\n+++ b/src/generator_spgemm_csr_reader.c\n@@ -17,8 +17,8 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                                 unsigned int**          o_row_idx,\n                                 unsigned int**          o_column_idx,\n                                 double**                o_values,\n-                                unsigned int*           o_row_count,\n-                                unsigned int*           o_column_count,\n+                                unsigned int*           io_row_count,\n+                                unsigned int*           io_column_count,\n                                 unsigned int*           o_element_count ) {\n   FILE *l_csr_file_handle;\n   const unsigned int l_line_length = 512;\n@@ -47,18 +47,21 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n     } else {\n       /* if we are the first line after comment header, we allocate our data structures */\n       if ( l_header_read == 0 ) {\n-        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n-            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n+        unsigned int row_count, column_count;\n+        if (3 == sscanf(l_line, \"%u %u %u\", &row_count, &column_count, o_element_count) &&\n+            0 != row_count && 0 != column_count && 0 != *o_element_count)\n         {\n+          *io_column_count = LIBXSMM_MAX(*io_column_count, column_count);\n+          *io_row_count = LIBXSMM_MAX(*io_row_count, row_count);\n           /* allocate CSC data-structure matching mtx file */\n           /* coverity[tainted_data] */\n           *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n+          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*io_row_count) + 1));\n           /* coverity[tainted_data] */\n           *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n+          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*io_row_count));\n \n           /* check if mallocs were successful */\n           if ( ( *o_row_idx == NULL )      ||\n@@ -74,17 +77,17 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n \n           /* set everything to zero for init */\n           /* coverity[tainted_data] */\n-          memset(*o_row_idx, 0, sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n+          memset(*o_row_idx, 0, sizeof(unsigned int) * ((size_t)(*io_row_count) + 1));\n           /* coverity[tainted_data] */\n           memset(*o_column_idx, 0, sizeof(unsigned int) * (*o_element_count));\n           /* coverity[tainted_data] */\n           memset(*o_values, 0, sizeof(double) * (*o_element_count));\n           /* coverity[tainted_data] */\n-          memset(l_row_idx_id, 0, sizeof(unsigned int) * (*o_row_count));\n+          memset(l_row_idx_id, 0, sizeof(unsigned int) * (*io_row_count));\n \n           /* init column idx */\n           /* coverity[tainted_data] */\n-          for ( l_i = 0; l_i <= *o_row_count; ++l_i )\n+          for ( l_i = 0; l_i <= *io_row_count; ++l_i )\n             (*o_row_idx)[l_i] = (*o_element_count);\n \n           /* init */\n@@ -136,7 +139,7 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n \n   if ( l_row_idx_id != NULL ) {\n     /* let's handle empty rows */\n-    for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n+    for ( l_i = 0; l_i < (*io_row_count); l_i++) {\n       if ( l_row_idx_id[l_i] == 0 ) {\n         (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n       }\ndiff --git a/src/generator_spgemm_csr_reader.h b/src/generator_spgemm_csr_reader.h\nindex a282870ff..1e852a77a 100644\n--- a/src/generator_spgemm_csr_reader.h\n+++ b/src/generator_spgemm_csr_reader.h\n@@ -21,8 +21,8 @@ void libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                                 unsigned int**          o_row_idx,\n                                 unsigned int**          o_column_idx,\n                                 double**                o_values,\n-                                unsigned int*           o_row_count,\n-                                unsigned int*           o_column_count,\n+                                unsigned int*           io_row_count,\n+                                unsigned int*           io_column_count,\n                                 unsigned int*           o_element_count );\n \n #endif /* GENERATOR_SPGEMM_CSR_READER_H */\ndiff --git a/version.txt b/version.txt\nindex 33e389bc4..a3e5fa366 100644\n--- a/version.txt\n+++ b/version.txt\n@@ -1 +1 @@\n-master-1.16.1-112\n+master-1.16.1-113",
        "test_patch": ""
    },
    {
        "instance_id": "json-c-json-c-654",
        "repo": "json-c/json-c",
        "created_at": "2020-08-05T02:18:37+00:00",
        "problem_statement": "A stack-buffer-overflow in json_parse.c:89:44\n\n## System info\r\n\r\nUbuntu X64, clang 6.0, json_parse (latest master [56a89f](https://github.com/json-c/json-c/commit/56a89f902f360c91a80ac0c7419d2ba1aa8e8634))\r\n\r\n## Configure\r\n\r\ncmake ..-DCMAKE_CXX_FLAGS=\"-fsanitize=address -g\" -DCMAKE_C_FLAGS=\"-fsanitize=address -g\" -DCMAKE_EXE_LINKER_FLAGS=\"-fsanitize=address\" \r\n\r\n## Command line\r\n\r\n./build/apps/json_parse -n ./stack-overflow-parseit-json_parse-89\r\n\r\n## AddressSanitizer output\r\n\r\n```\r\n=================================================================\r\n==12668==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffea9c409b0 at pc 0x00000051747b bp 0x7ffea9c388b0 sp 0x7ffea9c388a8\r\nREAD of size 1 at 0x7ffea9c409b0 thread T0\r\n    #0 0x51747a in parseit /home/seviezhou/jsonc/apps/json_parse.c:89:44\r\n    #1 0x51747a in main /home/seviezhou/jsonc/apps/json_parse.c:182\r\n    #2 0x7fc02a77783f in __libc_start_main /build/glibc-e6zv40/glibc-2.23/csu/../csu/libc-start.c:291\r\n    #3 0x41a928 in _start (/home/seviezhou/jsonc/build/apps/json_parse+0x41a928)\r\n\r\nAddress 0x7ffea9c409b0 is located in stack of thread T0 at offset 33008 in frame\r\n    #0 0x51651f in main /home/seviezhou/jsonc/apps/json_parse.c:159\r\n\r\n  This frame has 3 object(s):\r\n    [32, 176) 'rusage.i.i.i' (line 42)\r\n    [240, 33008) 'buf.i' (line 52) <== Memory access at offset 33008 overflows this variable\r\n    [33264, 33408) 'rusage.i' (line 42)\r\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext\r\n      (longjmp and C++ exceptions *are* supported)\r\nSUMMARY: AddressSanitizer: stack-buffer-overflow /home/seviezhou/jsonc/apps/json_parse.c:89:44 in parseit\r\nShadow bytes around the buggy address:\r\n  0x1000553800e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x1000553800f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x100055380100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x100055380110: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x100055380120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n=>0x100055380130: 00 00 00 00 00 00[f2]f2 f2 f2 f2 f2 f2 f2 f2 f2\r\n  0x100055380140: f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2\r\n  0x100055380150: f2 f2 f2 f2 f2 f2 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\r\n  0x100055380160: f8 f8 f8 f8 f8 f8 f8 f8 f3 f3 f3 f3 f3 f3 f3 f3\r\n  0x100055380170: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x100055380180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07\r\n  Heap left redzone:       fa\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Container overflow:      fc\r\n  Array cookie:            ac\r\n  Intra object redzone:    bb\r\n  ASan internal:           fe\r\n  Left alloca redzone:     ca\r\n  Right alloca redzone:    cb\r\n==12668==ABORTING\r\n```\r\n\r\n## POC\r\n\r\n[stack-overflow-parseit-json_parse-89.zip](https://github.com/json-c/json-c/files/5025755/stack-overflow-parseit-json_parse-89.zip)",
        "hints_text": "MarcT512: This is a read past end of buffer issue in the json_parse test app, which happened because your test data is malformed json.\r\nIt's not an issue with the library itself.\r\n\r\nI created a PR with a 1 line fix that prevents the issue in json_parse.\n\nseviezhou: I understand that, it is not a big issue. Maybe you can close this issue.\n\nMarcT512: It's a genuine issue and I'm sure the maintainers will appreciate the bug report (and hopefully the fix).\r\nIt was an interesting diversion for me to troubleshoot.\n\nseviezhou: Glad to hear that you are appreciate with the bug report! If I find other issues, I will inform you.\n\nhawicz: Thanks for the fix.",
        "base_commit": "730e3d044f2ac2e44e38bf67ac31c19925428d15",
        "patch": "diff --git a/apps/json_parse.c b/apps/json_parse.c\nindex bba4622..72b31a8 100644\n--- a/apps/json_parse.c\n+++ b/apps/json_parse.c\n@@ -82,7 +82,8 @@ static int parseit(int fd, int (*callback)(struct json_object *))\n \t\t\tint parse_end = json_tokener_get_parse_end(tok);\n \t\t\tif (obj == NULL && jerr != json_tokener_continue)\n \t\t\t{\n-\t\t\t\tchar *aterr = &buf[start_pos + parse_end];\n+\t\t\t\tchar *aterr = (start_pos + parse_end < sizeof(buf)) ?\n+\t\t\t\t\t&buf[start_pos + parse_end] : \"\";\n \t\t\t\tfflush(stdout);\n \t\t\t\tint fail_offset = total_read - ret + start_pos + parse_end;\n \t\t\t\tfprintf(stderr, \"Failed at offset %d: %s %c\\n\", fail_offset,",
        "test_patch": ""
    },
    {
        "instance_id": "gpac-gpac-1571",
        "repo": "gpac/gpac",
        "created_at": "2020-08-10T01:54:25+00:00",
        "problem_statement": "Malloc size error in box_code_base.c:7271\n\n## System info\r\n\r\nUbuntu x86_64, gcc (Ubuntu 5.5.0-12ubuntu1), MP4Box (latest master [2aa266](https://github.com/gpac/gpac/commit/2aa266dfaab6aaad9f9f4f216ad7d1e62adc7fa0))\r\n\r\n## Configure\r\n\r\nCFLAGS=\"-g -fsanitize=address\" LDFLAGS=\"-fsanitize=address\" ./configure --static-mp4box\r\n\r\n## Command line\r\n\r\n./bin/gcc/MP4Box -diso -out /dev/null @@\r\n\r\n## AddressSanitizer output\r\n\r\n```\r\n==18482==WARNING: AddressSanitizer failed to allocate 0x001939d11d00 bytes\r\n==18482==AddressSanitizer's allocator is terminating the process instead of returning 0\r\n==18482==If you don't like this behavior set allocator_may_return_null=1\r\n==18482==AddressSanitizer CHECK failed: ../../../../src/libsanitizer/sanitizer_common/sanitizer_allocator.cc:147 \"((0)) != (0)\" (0x0, 0x0)\r\n    #0 0x7f53458b3611  (/usr/lib/x86_64-linux-gnu/libasan.so.2+0xa0611)\r\n    #1 0x7f53458b85c3 in __sanitizer::CheckFailed(char const*, int, char const*, unsigned long long, unsigned long long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0xa55c3)\r\n    #2 0x7f5345830393  (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x1d393)\r\n    #3 0x7f53458b6845  (/usr/lib/x86_64-linux-gnu/libasan.so.2+0xa3845)\r\n    #4 0x7f5345835abd  (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x22abd)\r\n    #5 0x7f53458ab5e2 in malloc (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x985e2)\r\n    #6 0x563fc1ff6618 in trun_box_read isomedia/box_code_base.c:7271\r\n    #7 0x563fc0d3db64 in gf_isom_box_read isomedia/box_funcs.c:1681\r\n    #8 0x563fc0d3db64 in gf_isom_box_parse_ex isomedia/box_funcs.c:259\r\n    #9 0x563fc0d3f041 in gf_isom_parse_root_box isomedia/box_funcs.c:38\r\n    #10 0x563fc0d766f5 in gf_isom_parse_movie_boxes isomedia/isom_intern.c:259\r\n    #11 0x563fc0d81951 in gf_isom_parse_movie_boxes isomedia/isom_intern.c:247\r\n    #12 0x563fc0d81951 in gf_isom_open_file isomedia/isom_intern.c:740\r\n    #13 0x563fc06ab7e3 in mp4boxMain /home/seviezhou/gpac/applications/mp4box/main.c:5331\r\n    #14 0x7f534483fb96 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\r\n    #15 0x563fc067cf09 in _start (/home/seviezhou/gpac/bin/gcc/MP4Box+0x27ff09)\r\n```\r\n\r\n## POC\r\n\r\n[malloc-size-error-trun_box_read-box_code_base-7271.zip](https://github.com/gpac/gpac/files/5048775/malloc-size-error-trun_box_read-box_code_base-7271.zip)",
        "hints_text": "",
        "base_commit": "8e05648d6b4459facbc783025c5c42d301fef5c3",
        "patch": "diff --git a/src/isomedia/box_code_base.c b/src/isomedia/box_code_base.c\nindex 244cbbc17..6e71b9d59 100644\n--- a/src/isomedia/box_code_base.c\n+++ b/src/isomedia/box_code_base.c\n@@ -7268,6 +7268,10 @@ GF_Err trun_box_read(GF_Box *s, GF_BitStream *bs)\n \t\tptr->sample_alloc = ptr->nb_samples = 1;\n \t\tptr->samples[0].nb_pack = ptr->sample_count;\n \t} else {\n+\t\t//if we get here, at least one flag (so at least 4 bytes) is set, check size\n+\t\tif (ptr->sample_count * 4 > ptr->size) {\n+\t\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count*4);\n+\t\t}\n \t\tptr->samples = gf_malloc(sizeof(GF_TrunEntry) * ptr->sample_count);\n \t\tif (!ptr->samples) return GF_OUT_OF_MEM;\n \t\tptr->sample_alloc = ptr->nb_samples = ptr->sample_count;",
        "test_patch": ""
    },
    {
        "instance_id": "gpac-gpac-1570",
        "repo": "gpac/gpac",
        "created_at": "2020-08-10T01:49:17+00:00",
        "problem_statement": "A heap-buffer-overflow in box_code_adobe.c:168\n\n## System info\r\n\r\nUbuntu x86_64, gcc (Ubuntu 5.5.0-12ubuntu1), MP4Box (latest master [2aa266](https://github.com/gpac/gpac/commit/2aa266dfaab6aaad9f9f4f216ad7d1e62adc7fa0))\r\n\r\n## Configure\r\n\r\nCFLAGS=\"-g -fsanitize=address\" LDFLAGS=\"-fsanitize=address\" ./configure --static-mp4box\r\n\r\n## Command line\r\n\r\n./bin/gcc/MP4Box -diso -out /dev/null @@\r\n\r\n## AddressSanitizer output\r\n\r\n```\r\n=================================================================\r\n==3848==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000e119 at pc 0x7f931a0c33d5 bp 0x7fff7e91fcd0 sp 0x7fff7e91f478\r\nREAD of size 10 at 0x60200000e119 thread T0\r\n    #0 0x7f931a0c33d4 in strdup (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x623d4)\r\n    #1 0x563de374e827 in abst_box_read isomedia/box_code_adobe.c:168\r\n    #2 0x563de353db64 in gf_isom_box_read isomedia/box_funcs.c:1681\r\n    #3 0x563de353db64 in gf_isom_box_parse_ex isomedia/box_funcs.c:259\r\n    #4 0x563de353f041 in gf_isom_parse_root_box isomedia/box_funcs.c:38\r\n    #5 0x563de35766f5 in gf_isom_parse_movie_boxes isomedia/isom_intern.c:259\r\n    #6 0x563de3581951 in gf_isom_parse_movie_boxes isomedia/isom_intern.c:247\r\n    #7 0x563de3581951 in gf_isom_open_file isomedia/isom_intern.c:740\r\n    #8 0x563de2eab7e3 in mp4boxMain /home/seviezhou/gpac/applications/mp4box/main.c:5331\r\n    #9 0x7f931908db96 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\r\n    #10 0x563de2e7cf09 in _start (/home/seviezhou/gpac/bin/gcc/MP4Box+0x27ff09)\r\n\r\n0x60200000e119 is located 0 bytes to the right of 9-byte region [0x60200000e110,0x60200000e119)\r\nallocated by thread T0 here:\r\n    #0 0x7f931a0f9612 in malloc (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x98612)\r\n    #1 0x563de374c3a9 in abst_box_read isomedia/box_code_adobe.c:97\r\n\r\nSUMMARY: AddressSanitizer: heap-buffer-overflow ??:0 strdup\r\nShadow bytes around the buggy address:\r\n  0x0c047fff9bd0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c047fff9be0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c047fff9bf0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c047fff9c00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c047fff9c10: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n=>0x0c047fff9c20: fa fa 00[01]fa fa 00 00 fa fa 00 00 fa fa 00 00\r\n  0x0c047fff9c30: fa fa 00 00 fa fa 00 00 fa fa fd fa fa fa 00 fa\r\n  0x0c047fff9c40: fa fa 00 00 fa fa 00 00 fa fa 00 07 fa fa fd fa\r\n  0x0c047fff9c50: fa fa 00 02 fa fa 04 fa fa fa fd fa fa fa 07 fa\r\n  0x0c047fff9c60: fa fa fd fa fa fa 05 fa fa fa fd fa fa fa 00 fa\r\n  0x0c047fff9c70: fa fa fd fa fa fa 07 fa fa fa fd fa fa fa 07 fa\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07\r\n  Heap left redzone:       fa\r\n  Heap right redzone:      fb\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack partial redzone:   f4\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Container overflow:      fc\r\n  Array cookie:            ac\r\n  Intra object redzone:    bb\r\n  ASan internal:           fe\r\n==3848==ABORTING\r\n```\r\n\r\n## POC\r\n\r\n[heap-overflow-abst_box_read-box_code_adobe-168.zip](https://github.com/gpac/gpac/files/5048763/heap-overflow-abst_box_read-box_code_adobe-168.zip)",
        "hints_text": "jeanlf: fixed by #1568 ",
        "base_commit": "ce01bd15f711d4575b7424b54b3a395ec64c1784",
        "patch": "diff --git a/src/isomedia/box_code_adobe.c b/src/isomedia/box_code_adobe.c\nindex eafdabff1..ab5115f25 100644\n--- a/src/isomedia/box_code_adobe.c\n+++ b/src/isomedia/box_code_adobe.c\n@@ -93,7 +93,7 @@ GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n \n \ti=0;\n \tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n-\ttmp_strsize =(u32)ptr->size-8;\n+\ttmp_strsize =(u32)ptr->size;\n \ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n \tif (!tmp_str) return GF_OUT_OF_MEM;\n \tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);",
        "test_patch": ""
    },
    {
        "instance_id": "LibreDWG-libredwg-265",
        "repo": "LibreDWG/libredwg",
        "created_at": "2020-08-04T12:26:27+00:00",
        "problem_statement": "An unknown crash in decode.c:2264\n\n## System info\r\n\r\nUbuntu X64, gcc (Ubuntu 5.5.0-12ubuntu1), dwg2dxf (latest master [66a348](https://github.com/LibreDWG/libredwg/commit/66a3484bda00ff5af2bdb79e41db3b066fdd0d00))\r\n\r\n## Configure\r\n\r\nCFLAGS=\"-g -fsanitize=address\" LDFLAGS=\"-fsanitize=address\" ./configure\r\n\r\n## Command line\r\n\r\n./programs/dwg2dxf -b -m ./unknown-crash-read_R2004_section_info -o /dev/null\r\n\r\n## AddressSanitizer output\r\n\r\n```\r\n=================================================================\r\n==1707==ERROR: AddressSanitizer: unknown-crash on address 0x619000009ff4 at pc 0x5586380c6d59 bp 0x7fff56f61360 sp 0x7fff56f61350\r\nREAD of size 16 at 0x619000009ff4 thread T0\r\n    #0 0x5586380c6d58 in read_R2004_section_info /home/seviezhou/libredwg/src/decode.c:2264\r\n    #1 0x5586380c6d58 in decode_R2004 /home/seviezhou/libredwg/src/decode.c:3672\r\n    #2 0x5586380cc3fe in dwg_decode /home/seviezhou/libredwg/src/decode.c:242\r\n    #3 0x558637fc37da in dwg_read_file /home/seviezhou/libredwg/src/dwg.c:251\r\n    #4 0x558637fc0f0a in main /home/seviezhou/libredwg/programs/dwg2dxf.c:258\r\n    #5 0x7f86772bbb96 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\r\n    #6 0x558637fc1df9 in _start (/home/seviezhou/libredwg/programs/dwg2dxf+0xa8cdf9)\r\n\r\n0x61900000a000 is located 0 bytes to the right of 1152-byte region [0x619000009b80,0x61900000a000)\r\nallocated by thread T0 here:\r\n    #0 0x7f8677ac17aa in __interceptor_calloc (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x987aa)\r\n    #1 0x5586380c5643 in read_R2004_section_info /home/seviezhou/libredwg/src/decode.c:2110\r\n    #2 0x5586380c5643 in decode_R2004 /home/seviezhou/libredwg/src/decode.c:3672\r\n    #3 0x5586380cc3fe in dwg_decode /home/seviezhou/libredwg/src/decode.c:242\r\n\r\nSUMMARY: AddressSanitizer: unknown-crash /home/seviezhou/libredwg/src/decode.c:2264 read_R2004_section_info\r\nShadow bytes around the buggy address:\r\n  0x0c327fff93a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0c327fff93b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0c327fff93c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0c327fff93d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0c327fff93e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n=>0x0c327fff93f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00[00]00\r\n  0x0c327fff9400: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c327fff9410: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\r\n  0x0c327fff9420: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\r\n  0x0c327fff9430: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\r\n  0x0c327fff9440: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07\r\n  Heap left redzone:       fa\r\n  Heap right redzone:      fb\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack partial redzone:   f4\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Container overflow:      fc\r\n  Array cookie:            ac\r\n  Intra object redzone:    bb\r\n  ASan internal:           fe\r\n==1707==ABORTING\r\n```\r\n\r\n## POC\r\n\r\n[unknown-crash-read_R2004_section_info-decode-2264.zip](https://github.com/LibreDWG/libredwg/files/5022051/unknown-crash-read_R2004_section_info-decode-2264.zip)",
        "hints_text": "",
        "base_commit": "7e8725315e262e505693b43285022214f4738c63",
        "patch": "diff --git a/src/decode.c b/src/decode.c\nindex 7c7c7f38..ffaab0d9 100644\n--- a/src/decode.c\n+++ b/src/decode.c\n@@ -2244,6 +2244,14 @@ read_R2004_section_info (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                 uint32_t size;\n                 uint64_t address;\n               } page;\n+\n+              if (ptr + 16 >= decomp_end)\n+                {\n+                  LOG_ERROR (\"read_R2004_section_info[%u] out of range, abort\", j);\n+                  info->num_sections = j;\n+                  error |= DWG_ERR_SECTIONNOTFOUND;\n+                  break;\n+                }\n               /* endian specific code: */\n               bfr_read (&page, &ptr, 16);\n               sum_decomp += page.size; /* TODO: uncompressed size */\n@@ -2253,7 +2261,7 @@ read_R2004_section_info (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                   /* ODA: \"If the start offset is smaller than the sum of the decompressed\n                    * size of all previous pages, then this page is to be preceded by\n                    * zero pages until this condition is met. */\n-                  LOG_WARN(\"address %lu < sum_decomp %lu\", page.address, sum_decomp)\n+                  LOG_WARN (\"address %lu < sum_decomp %lu\", page.address, sum_decomp)\n                 }\n #endif\n               info->sections[j] = find_section (dwg, page.number);",
        "test_patch": ""
    },
    {
        "instance_id": "LibreDWG-libredwg-262",
        "repo": "LibreDWG/libredwg",
        "created_at": "2020-08-03T14:19:33+00:00",
        "problem_statement": "A Segmentation fault in bits.c:186\n\n## System info\r\n\r\nUbuntu X64, gcc (Ubuntu 5.5.0-12ubuntu1), dwg2dxf (latest master [bacd017](https://github.com/LibreDWG/libredwg/commit/bacd01778d20b7b79f28541ea7a60cafe25175aa))\r\n## Configure\r\n\r\nCFLAGS=\"-g -fsanitize=address\" LDFLAGS=\"-fsanitize=address\" ./configure\r\n\r\n## Command line\r\n\r\n./programs/dwg2dxf -b -m ./SEGV-bit_read_BB-bits-186 -o /dev/null\r\n\r\n## Output\r\n\r\n```\r\nSegmentation fault (core dumped)\r\n```\r\n\r\n## AddressSanitizer output\r\n\r\n```\r\nASAN:SIGSEGV\r\n=================================================================\r\n==33413==ERROR: AddressSanitizer: SEGV on unknown address 0x63001eedeec1 (pc 0x56001ae1aa1c bp 0x7ffc0f008820 sp 0x7ffc0f008570 T0)\r\n    #0 0x56001ae1aa1b in bit_read_BB /home/seviezhou/libredwg/src/bits.c:186\r\n    #1 0x56001ae3d11b in bit_read_BS /home/seviezhou/libredwg/src/bits.c:525\r\n    #2 0x56001ae3d11b in bit_read_TU /home/seviezhou/libredwg/src/bits.c:1891\r\n    #3 0x56001ae4d52b in bit_read_CMC /home/seviezhou/libredwg/src/bits.c:2610\r\n    #4 0x56001a5261c2 in dwg_decode_VIEWPORT_private /home/seviezhou/libredwg/src/dwg.spec:1674\r\n    #5 0x56001aef02ff in dwg_decode_VIEWPORT /home/seviezhou/libredwg/src/dwg.spec:1607\r\n    #6 0x56001aef02ff in dwg_decode_add_object /home/seviezhou/libredwg/src/decode.c:5583\r\n    #7 0x56001aef77b8 in read_2004_section_handles /home/seviezhou/libredwg/src/decode.c:2843\r\n    #8 0x56001aef77b8 in decode_R2004 /home/seviezhou/libredwg/src/decode.c:3682\r\n    #9 0x56001af060ba in dwg_decode /home/seviezhou/libredwg/src/decode.c:242\r\n    #10 0x56001adfcd94 in dwg_read_file /home/seviezhou/libredwg/src/dwg.c:251\r\n    #11 0x56001adfa242 in main /home/seviezhou/libredwg/programs/dwg2dxf.c:258\r\n    #12 0x7f13152a8b96 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\r\n    #13 0x56001adfb2b9 in _start (/home/seviezhou/libredwg/programs/dwg2dxf+0xa8d2b9)\r\n\r\nAddressSanitizer can not provide additional info.\r\nSUMMARY: AddressSanitizer: SEGV /home/seviezhou/libredwg/src/bits.c:186 bit_read_BB\r\n==33413==ABORTING\r\n```\r\n\r\n## POC\r\n\r\n[SEGV-bit_read_BB-bits-186.zip](https://github.com/LibreDWG/libredwg/files/5016490/SEGV-bit_read_BB-bits-186.zip)",
        "hints_text": "rurban: The root cause is wrong error handling of obj_string_stream overflow (illegal str_dat stream bounds)\n\nrurban: Fixed with 66a3484bda00ff5af2bdb79e41db3b066fdd0d00",
        "base_commit": "3995ebb2c76087ed2e0deb145f3763a8cb1f043f",
        "patch": "diff --git a/src/decode_r2007.c b/src/decode_r2007.c\nindex 7b94daec..e48fed5c 100644\n--- a/src/decode_r2007.c\n+++ b/src/decode_r2007.c\n@@ -1307,7 +1307,12 @@ obj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n \n   if (str->byte >= old_size - old_byte)\n     {\n-      LOG_WARN (\"obj_string_stream overflow\");\n+      LOG_ERROR (\"obj_string_stream overflow, bitsize \" FORMAT_RL \" => \" FORMAT_RL,\n+                 obj->bitsize, obj->size * 8);\n+      str->byte = old_byte;\n+      str->size = old_size;\n+      obj->has_strings = 0;\n+      obj->bitsize = obj->size * 8;\n       return DWG_ERR_VALUEOUTOFBOUNDS;\n     }\n   LOG_HANDLE (\" obj string stream +%u: @%lu.%u (%lu)\", start, str->byte,",
        "test_patch": ""
    }
]